package build

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"encoding/json"

	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/date"
	uuid "github.com/satori/go.uuid"
)

// The package's fully qualified name.
const fqdn = "build-go"

// DefinitionQueryOrder enumerates the values for definition query order.
type DefinitionQueryOrder string

const (
	// DefinitionNameAscending Order by definition name ascending.
	DefinitionNameAscending DefinitionQueryOrder = "definitionNameAscending"
	// DefinitionNameDescending Order by definition name descending.
	DefinitionNameDescending DefinitionQueryOrder = "definitionNameDescending"
	// LastModifiedAscending Order by created on/last modified time ascending.
	LastModifiedAscending DefinitionQueryOrder = "lastModifiedAscending"
	// LastModifiedDescending Order by created on/last modified time descending.
	LastModifiedDescending DefinitionQueryOrder = "lastModifiedDescending"
	// None No order
	None DefinitionQueryOrder = "none"
)

// PossibleDefinitionQueryOrderValues returns an array of possible values for the DefinitionQueryOrder const type.
func PossibleDefinitionQueryOrderValues() []DefinitionQueryOrder {
	return []DefinitionQueryOrder{DefinitionNameAscending, DefinitionNameDescending, LastModifiedAscending, LastModifiedDescending, None}
}

// FolderQueryOrder enumerates the values for folder query order.
type FolderQueryOrder string

const (
	// FolderQueryOrderFolderAscending Order by folder name and path ascending.
	FolderQueryOrderFolderAscending FolderQueryOrder = "folderAscending"
	// FolderQueryOrderFolderDescending Order by folder name and path descending.
	FolderQueryOrderFolderDescending FolderQueryOrder = "folderDescending"
	// FolderQueryOrderNone No order
	FolderQueryOrderNone FolderQueryOrder = "none"
)

// PossibleFolderQueryOrderValues returns an array of possible values for the FolderQueryOrder const type.
func PossibleFolderQueryOrderValues() []FolderQueryOrder {
	return []FolderQueryOrder{FolderQueryOrderFolderAscending, FolderQueryOrderFolderDescending, FolderQueryOrderNone}
}

// QueryDeletedOption enumerates the values for query deleted option.
type QueryDeletedOption string

const (
	// ExcludeDeleted Include only non-deleted builds.
	ExcludeDeleted QueryDeletedOption = "excludeDeleted"
	// IncludeDeleted Include deleted and non-deleted builds.
	IncludeDeleted QueryDeletedOption = "includeDeleted"
	// OnlyDeleted Include only deleted builds.
	OnlyDeleted QueryDeletedOption = "onlyDeleted"
)

// PossibleQueryDeletedOptionValues returns an array of possible values for the QueryDeletedOption const type.
func PossibleQueryDeletedOptionValues() []QueryDeletedOption {
	return []QueryDeletedOption{ExcludeDeleted, IncludeDeleted, OnlyDeleted}
}

// QueryOrder enumerates the values for query order.
type QueryOrder string

const (
	// FinishTimeAscending Order by finish time ascending.
	FinishTimeAscending QueryOrder = "finishTimeAscending"
	// FinishTimeDescending Order by finish time descending.
	FinishTimeDescending QueryOrder = "finishTimeDescending"
	// QueueTimeAscending Order by queue time ascending.
	QueueTimeAscending QueryOrder = "queueTimeAscending"
	// QueueTimeDescending Order by queue time descending.
	QueueTimeDescending QueryOrder = "queueTimeDescending"
	// StartTimeAscending Order by start time ascending.
	StartTimeAscending QueryOrder = "startTimeAscending"
	// StartTimeDescending Order by start time descending.
	StartTimeDescending QueryOrder = "startTimeDescending"
)

// PossibleQueryOrderValues returns an array of possible values for the QueryOrder const type.
func PossibleQueryOrderValues() []QueryOrder {
	return []QueryOrder{FinishTimeAscending, FinishTimeDescending, QueueTimeAscending, QueueTimeDescending, StartTimeAscending, StartTimeDescending}
}

// Reason enumerates the values for reason.
type Reason string

const (
	// ReasonAll All reasons.
	ReasonAll Reason = "all"
	// ReasonBatchedCI The build was started for the trigger TriggerType.BatchedContinuousIntegration.
	ReasonBatchedCI Reason = "batchedCI"
	// ReasonBuildCompletion The build was started when another build completed.
	ReasonBuildCompletion Reason = "buildCompletion"
	// ReasonCheckInShelveset The build was started for the trigger ContinuousIntegrationType.Gated.
	ReasonCheckInShelveset Reason = "checkInShelveset"
	// ReasonIndividualCI The build was started for the trigger TriggerType.ContinuousIntegration.
	ReasonIndividualCI Reason = "individualCI"
	// ReasonManual The build was started manually.
	ReasonManual Reason = "manual"
	// ReasonNone No reason. This value should not be used.
	ReasonNone Reason = "none"
	// ReasonPullRequest The build was started by a pull request. Added in resource version 3.
	ReasonPullRequest Reason = "pullRequest"
	// ReasonSchedule The build was started for the trigger TriggerType.Schedule.
	ReasonSchedule Reason = "schedule"
	// ReasonTriggered The build was triggered for retention policy purposes.
	ReasonTriggered Reason = "triggered"
	// ReasonUserCreated The build was created by a user.
	ReasonUserCreated Reason = "userCreated"
	// ReasonValidateShelveset The build was started manually for private validation.
	ReasonValidateShelveset Reason = "validateShelveset"
)

// PossibleReasonValues returns an array of possible values for the Reason const type.
func PossibleReasonValues() []Reason {
	return []Reason{ReasonAll, ReasonBatchedCI, ReasonBuildCompletion, ReasonCheckInShelveset, ReasonIndividualCI, ReasonManual, ReasonNone, ReasonPullRequest, ReasonSchedule, ReasonTriggered, ReasonUserCreated, ReasonValidateShelveset}
}

// Result enumerates the values for result.
type Result string

const (
	// ResultCanceled The build was canceled before starting.
	ResultCanceled Result = "canceled"
	// ResultFailed The build completed unsuccessfully.
	ResultFailed Result = "failed"
	// ResultNone No result
	ResultNone Result = "none"
	// ResultPartiallySucceeded The build completed compilation successfully but had other errors.
	ResultPartiallySucceeded Result = "partiallySucceeded"
	// ResultSucceeded The build completed successfully.
	ResultSucceeded Result = "succeeded"
)

// PossibleResultValues returns an array of possible values for the Result const type.
func PossibleResultValues() []Result {
	return []Result{ResultCanceled, ResultFailed, ResultNone, ResultPartiallySucceeded, ResultSucceeded}
}

// ResultSet enumerates the values for result set.
type ResultSet string

const (
	// All Include all repositories
	All ResultSet = "all"
	// Top Include most relevant repositories for user
	Top ResultSet = "top"
)

// PossibleResultSetValues returns an array of possible values for the ResultSet const type.
func PossibleResultSetValues() []ResultSet {
	return []ResultSet{All, Top}
}

// Status enumerates the values for status.
type Status string

const (
	// StatusAll All status.
	StatusAll Status = "all"
	// StatusCancelling The build is cancelling
	StatusCancelling Status = "cancelling"
	// StatusCompleted The build has completed.
	StatusCompleted Status = "completed"
	// StatusInProgress The build is currently in progress.
	StatusInProgress Status = "inProgress"
	// StatusNone No status.
	StatusNone Status = "none"
	// StatusNotStarted The build has not yet started.
	StatusNotStarted Status = "notStarted"
	// StatusPostponed The build is inactive in the queue.
	StatusPostponed Status = "postponed"
)

// PossibleStatusValues returns an array of possible values for the Status const type.
func PossibleStatusValues() []Status {
	return []Status{StatusAll, StatusCancelling, StatusCompleted, StatusInProgress, StatusNone, StatusNotStarted, StatusPostponed}
}

// Agent ...
type Agent struct {
	BuildDirectory   *string                       `json:"buildDirectory,omitempty"`
	Controller       *XamlBuildControllerReference `json:"controller,omitempty"`
	CreatedDate      *date.Time                    `json:"createdDate,omitempty"`
	Description      *string                       `json:"description,omitempty"`
	Enabled          *bool                         `json:"enabled,omitempty"`
	ID               *int32                        `json:"id,omitempty"`
	MessageQueueURL  *string                       `json:"messageQueueUrl,omitempty"`
	Name             *string                       `json:"name,omitempty"`
	ReservedForBuild *string                       `json:"reservedForBuild,omitempty"`
	Server           *XamlBuildServerReference     `json:"server,omitempty"`
	Status           interface{}                   `json:"status,omitempty"`
	StatusMessage    *string                       `json:"statusMessage,omitempty"`
	UpdatedDate      *date.Time                    `json:"updatedDate,omitempty"`
	URI              *string                       `json:"uri,omitempty"`
	URL              *string                       `json:"url,omitempty"`
}

// AgentPoolQueue represents a queue for running builds.
type AgentPoolQueue struct {
	Links *ReferenceLinks `json:"_links,omitempty"`
	// ID - The ID of the queue.
	ID *int32 `json:"id,omitempty"`
	// Name - The name of the queue.
	Name *string `json:"name,omitempty"`
	// Pool - The pool used by this queue.
	Pool *TaskAgentPoolReference `json:"pool,omitempty"`
	// URL - The full http link to the resource.
	URL *string `json:"url,omitempty"`
}

// AgentPoolQueueReference represents a reference to an agent queue.
type AgentPoolQueueReference struct {
	// ID - The ID of the queue.
	ID *int32 `json:"id,omitempty"`
	// Alias - An alias to be used when referencing the resource.
	Alias *string `json:"alias,omitempty"`
}

// AgentPoolQueueTarget describes how a phase should run against an agent queue.
type AgentPoolQueueTarget struct {
	// AgentSpecification - Agent specification of the target.
	AgentSpecification *AgentSpecification `json:"agentSpecification,omitempty"`
	// AllowScriptsAuthAccessOption - Enables scripts and other processes launched while executing phase to access the OAuth token
	AllowScriptsAuthAccessOption *bool     `json:"allowScriptsAuthAccessOption,omitempty"`
	Demands                      *[]Demand `json:"demands,omitempty"`
	// ExecutionOptions - The execution options.
	ExecutionOptions *AgentTargetExecutionOptions `json:"executionOptions,omitempty"`
	// Queue - The queue.
	Queue *AgentPoolQueue `json:"queue,omitempty"`
	// Type - The type of the target.
	Type *int32 `json:"type,omitempty"`
}

// AgentReference ...
type AgentReference struct {
	// ID - Id of the resource
	ID *int32 `json:"id,omitempty"`
	// Name - Name of the linked resource (definition name, controller name, etc.)
	Name *string `json:"name,omitempty"`
	// URL - Full http link to the resource
	URL *string `json:"url,omitempty"`
}

// AgentSpecification specification of the agent defined by the pool provider.
type AgentSpecification struct {
	// Identifier - Agent specification unique identifier.
	Identifier *string `json:"identifier,omitempty"`
}

// AgentTargetExecutionOptions additional options for running phases against an agent queue.
type AgentTargetExecutionOptions struct {
	// Type - Indicates the type of execution options.
	Type *int32 `json:"type,omitempty"`
}

// AggregatedResultsAnalysis ...
type AggregatedResultsAnalysis struct {
	Duration                    *string                                `json:"duration,omitempty"`
	NotReportedResultsByOutcome map[string]*AggregatedResultsByOutcome `json:"notReportedResultsByOutcome"`
	PreviousContext             *TestResultsContext                    `json:"previousContext,omitempty"`
	ResultsByOutcome            map[string]*AggregatedResultsByOutcome `json:"resultsByOutcome"`
	ResultsDifference           *AggregatedResultsDifference           `json:"resultsDifference,omitempty"`
	RunSummaryByOutcome         map[string]*AggregatedRunsByOutcome    `json:"runSummaryByOutcome"`
	RunSummaryByState           map[string]*AggregatedRunsByState      `json:"runSummaryByState"`
	TotalTests                  *int32                                 `json:"totalTests,omitempty"`
}

// MarshalJSON is the custom marshaler for AggregatedResultsAnalysis.
func (ara AggregatedResultsAnalysis) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ara.Duration != nil {
		objectMap["duration"] = ara.Duration
	}
	if ara.NotReportedResultsByOutcome != nil {
		objectMap["notReportedResultsByOutcome"] = ara.NotReportedResultsByOutcome
	}
	if ara.PreviousContext != nil {
		objectMap["previousContext"] = ara.PreviousContext
	}
	if ara.ResultsByOutcome != nil {
		objectMap["resultsByOutcome"] = ara.ResultsByOutcome
	}
	if ara.ResultsDifference != nil {
		objectMap["resultsDifference"] = ara.ResultsDifference
	}
	if ara.RunSummaryByOutcome != nil {
		objectMap["runSummaryByOutcome"] = ara.RunSummaryByOutcome
	}
	if ara.RunSummaryByState != nil {
		objectMap["runSummaryByState"] = ara.RunSummaryByState
	}
	if ara.TotalTests != nil {
		objectMap["totalTests"] = ara.TotalTests
	}
	return json.Marshal(objectMap)
}

// AggregatedResultsByOutcome ...
type AggregatedResultsByOutcome struct {
	Count            *int32      `json:"count,omitempty"`
	Duration         *string     `json:"duration,omitempty"`
	GroupByField     *string     `json:"groupByField,omitempty"`
	GroupByValue     interface{} `json:"groupByValue,omitempty"`
	Outcome          interface{} `json:"outcome,omitempty"`
	RerunResultCount *int32      `json:"rerunResultCount,omitempty"`
}

// AggregatedResultsDifference ...
type AggregatedResultsDifference struct {
	IncreaseInDuration    *string `json:"increaseInDuration,omitempty"`
	IncreaseInFailures    *int32  `json:"increaseInFailures,omitempty"`
	IncreaseInOtherTests  *int32  `json:"increaseInOtherTests,omitempty"`
	IncreaseInPassedTests *int32  `json:"increaseInPassedTests,omitempty"`
	IncreaseInTotalTests  *int32  `json:"increaseInTotalTests,omitempty"`
}

// AggregatedRunsByOutcome ...
type AggregatedRunsByOutcome struct {
	Outcome   interface{} `json:"outcome,omitempty"`
	RunsCount *int32      `json:"runsCount,omitempty"`
}

// AggregatedRunsByState ...
type AggregatedRunsByState struct {
	ResultsByOutcome map[string]*AggregatedResultsByOutcome `json:"resultsByOutcome"`
	RunsCount        *int32                                 `json:"runsCount,omitempty"`
	State            interface{}                            `json:"state,omitempty"`
}

// MarshalJSON is the custom marshaler for AggregatedRunsByState.
func (arbs AggregatedRunsByState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if arbs.ResultsByOutcome != nil {
		objectMap["resultsByOutcome"] = arbs.ResultsByOutcome
	}
	if arbs.RunsCount != nil {
		objectMap["runsCount"] = arbs.RunsCount
	}
	if arbs.State != nil {
		objectMap["state"] = arbs.State
	}
	return json.Marshal(objectMap)
}

// Artifact represents an artifact produced by a build.
type Artifact struct {
	autorest.Response `json:"-"`
	// ID - The artifact ID.
	ID *int32 `json:"id,omitempty"`
	// Name - The name of the artifact.
	Name *string `json:"name,omitempty"`
	// Resource - The actual resource.
	Resource *ArtifactResource `json:"resource,omitempty"`
}

// ArtifactResource ...
type ArtifactResource struct {
	Links *ReferenceLinks `json:"_links,omitempty"`
	// Data - Type-specific data about the artifact.
	Data *string `json:"data,omitempty"`
	// DownloadURL - A link to download the resource.
	DownloadURL *string `json:"downloadUrl,omitempty"`
	// Properties - Type-specific properties of the artifact.
	Properties map[string]*string `json:"properties"`
	// Type - The type of the resource: File container, version control folder, UNC path, etc.
	Type *string `json:"type,omitempty"`
	// URL - The full http link to the resource.
	URL *string `json:"url,omitempty"`
}

// MarshalJSON is the custom marshaler for ArtifactResource.
func (ar ArtifactResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ar.Links != nil {
		objectMap["_links"] = ar.Links
	}
	if ar.Data != nil {
		objectMap["data"] = ar.Data
	}
	if ar.DownloadURL != nil {
		objectMap["downloadUrl"] = ar.DownloadURL
	}
	if ar.Properties != nil {
		objectMap["properties"] = ar.Properties
	}
	if ar.Type != nil {
		objectMap["type"] = ar.Type
	}
	if ar.URL != nil {
		objectMap["url"] = ar.URL
	}
	return json.Marshal(objectMap)
}

// AssociatedWorkItem ...
type AssociatedWorkItem struct {
	AssignedTo *string `json:"assignedTo,omitempty"`
	// ID - Id of associated the work item.
	ID    *int32  `json:"id,omitempty"`
	State *string `json:"state,omitempty"`
	Title *string `json:"title,omitempty"`
	// URL - REST Url of the work item.
	URL          *string `json:"url,omitempty"`
	WebURL       *string `json:"webUrl,omitempty"`
	WorkItemType *string `json:"workItemType,omitempty"`
}

// Attachment represents an attachment to a build.
type Attachment struct {
	Links *ReferenceLinks `json:"_links,omitempty"`
	// Name - The name of the attachment.
	Name *string `json:"name,omitempty"`
}

// AuthorizationHeader ...
type AuthorizationHeader struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// Badge represents a build badge.
type Badge struct {
	// BuildID - The ID of the build represented by this badge.
	BuildID *int32 `json:"buildId,omitempty"`
	// ImageURL - A link to the SVG resource.
	ImageURL *string `json:"imageUrl,omitempty"`
}

// BuildsDeletedEvent1Type ...
type BuildsDeletedEvent1Type struct {
	BuildIds *[]int32 `json:"buildIds,omitempty"`
	// DefinitionID - The ID of the definition.
	DefinitionID *int32 `json:"definitionId,omitempty"`
	// ProjectID - The ID of the project.
	ProjectID *uuid.UUID `json:"projectId,omitempty"`
}

// BuildsDeletedEventType ...
type BuildsDeletedEventType struct {
	BuildIds *[]int32 `json:"buildIds,omitempty"`
	// DefinitionID - The ID of the definition.
	DefinitionID *int32 `json:"definitionId,omitempty"`
	// ProjectID - The ID of the project.
	ProjectID *uuid.UUID `json:"projectId,omitempty"`
}

// Change represents a change associated with a build.
type Change struct {
	// Author - The author of the change.
	Author *IdentityRef `json:"author,omitempty"`
	// DisplayURI - The location of a user-friendly representation of the resource.
	DisplayURI *string `json:"displayUri,omitempty"`
	// ID - The identifier for the change. For a commit, this would be the SHA1. For a TFVC changeset, this would be the changeset ID.
	ID *string `json:"id,omitempty"`
	// Location - The location of the full representation of the resource.
	Location *string `json:"location,omitempty"`
	// Message - The description of the change. This might be a commit message or changeset description.
	Message *string `json:"message,omitempty"`
	// MessageTruncated - Indicates whether the message was truncated.
	MessageTruncated *bool `json:"messageTruncated,omitempty"`
	// Pusher - The person or process that pushed the change.
	Pusher *string `json:"pusher,omitempty"`
	// Timestamp - The timestamp for the change.
	Timestamp *date.Time `json:"timestamp,omitempty"`
	// Type - The type of change. "commit", "changeset", etc.
	Type *string `json:"type,omitempty"`
}

// CompletedEvent ...
type CompletedEvent struct {
	// Changes - Changes associated with a build used for build notifications
	Changes *[]Change `json:"changes,omitempty"`
	// PullRequest - Pull request for the build used for build notifications
	PullRequest *PullRequest `json:"pullRequest,omitempty"`
	// TestResults - Test results associated with a build used for build notifications
	TestResults *AggregatedResultsAnalysis `json:"testResults,omitempty"`
	// TimelineRecords - Timeline records associated with a build used for build notifications
	TimelineRecords *[]TimelineRecord `json:"timelineRecords,omitempty"`
	// WorkItems - Work items associated with a build used for build notifications
	WorkItems     *[]AssociatedWorkItem `json:"workItems,omitempty"`
	BuildProperty *Model                `json:"build,omitempty"`
	BuildID       *int32                `json:"buildId,omitempty"`
}

// CompletionTrigger represents a build completion trigger.
type CompletionTrigger struct {
	BranchFilters *[]string `json:"branchFilters,omitempty"`
	// Definition - A reference to the definition that should trigger builds for this definition.
	Definition              *DefinitionReference `json:"definition,omitempty"`
	RequiresSuccessfulBuild *bool                `json:"requiresSuccessfulBuild,omitempty"`
	// TriggerType - The type of the trigger.
	TriggerType interface{} `json:"triggerType,omitempty"`
}

// ConsoleLogEvent ...
type ConsoleLogEvent struct {
	Lines            *[]string  `json:"lines,omitempty"`
	StepRecordID     *uuid.UUID `json:"stepRecordId,omitempty"`
	TimelineID       *uuid.UUID `json:"timelineId,omitempty"`
	TimelineRecordID *uuid.UUID `json:"timelineRecordId,omitempty"`
	BuildID          *int32     `json:"buildId,omitempty"`
}

// ContinuousDeploymentDefinition ...
type ContinuousDeploymentDefinition struct {
	// ConnectedService - The connected service associated with the continuous deployment
	ConnectedService *WebAPIConnectedServiceRef `json:"connectedService,omitempty"`
	// Definition - The definition associated with the continuous deployment
	Definition         *XamlDefinitionReference `json:"definition,omitempty"`
	GitBranch          *string                  `json:"gitBranch,omitempty"`
	HostedServiceName  *string                  `json:"hostedServiceName,omitempty"`
	Project            *TeamProjectReference    `json:"project,omitempty"`
	RepositoryID       *string                  `json:"repositoryId,omitempty"`
	StorageAccountName *string                  `json:"storageAccountName,omitempty"`
	SubscriptionID     *string                  `json:"subscriptionId,omitempty"`
	Website            *string                  `json:"website,omitempty"`
	Webspace           *string                  `json:"webspace,omitempty"`
}

// ContinuousIntegrationTrigger represents a continuous integration (CI) trigger.
type ContinuousIntegrationTrigger struct {
	// BatchChanges - Indicates whether changes should be batched while another CI build is running.
	BatchChanges  *bool     `json:"batchChanges,omitempty"`
	BranchFilters *[]string `json:"branchFilters,omitempty"`
	// MaxConcurrentBuildsPerBranch - The maximum number of simultaneous CI builds that will run per branch.
	MaxConcurrentBuildsPerBranch *int32    `json:"maxConcurrentBuildsPerBranch,omitempty"`
	PathFilters                  *[]string `json:"pathFilters,omitempty"`
	// PollingInterval - The polling interval, in seconds.
	PollingInterval *int32 `json:"pollingInterval,omitempty"`
	// PollingJobID - The ID of the job used to poll an external repository.
	PollingJobID       *uuid.UUID `json:"pollingJobId,omitempty"`
	SettingsSourceType *int32     `json:"settingsSourceType,omitempty"`
	// TriggerType - The type of the trigger.
	TriggerType interface{} `json:"triggerType,omitempty"`
}

// Controller ...
type Controller struct {
	autorest.Response `json:"-"`
	Links             *ReferenceLinks `json:"_links,omitempty"`
	// CreatedDate - The date the controller was created.
	CreatedDate *date.Time `json:"createdDate,omitempty"`
	// Description - The description of the controller.
	Description *string `json:"description,omitempty"`
	// Enabled - Indicates whether the controller is enabled.
	Enabled *bool `json:"enabled,omitempty"`
	// Status - The status of the controller.
	Status interface{} `json:"status,omitempty"`
	// UpdatedDate - The date the controller was last updated.
	UpdatedDate *date.Time `json:"updatedDate,omitempty"`
	// URI - The controller's URI.
	URI *string `json:"uri,omitempty"`
	// ID - Id of the resource
	ID *int32 `json:"id,omitempty"`
	// Name - Name of the linked resource (definition name, controller name, etc.)
	Name *string `json:"name,omitempty"`
	// URL - Full http link to the resource
	URL *string `json:"url,omitempty"`
}

// DataSourceBindingBase represents binding of data source for the service endpoint request.
type DataSourceBindingBase struct {
	// CallbackContextTemplate - Pagination format supported by this data source(ContinuationToken/SkipTop).
	CallbackContextTemplate *string `json:"callbackContextTemplate,omitempty"`
	// CallbackRequiredTemplate - Subsequent calls needed?
	CallbackRequiredTemplate *string `json:"callbackRequiredTemplate,omitempty"`
	// DataSourceName - Gets or sets the name of the data source.
	DataSourceName *string `json:"dataSourceName,omitempty"`
	// EndpointID - Gets or sets the endpoint Id.
	EndpointID *string `json:"endpointId,omitempty"`
	// EndpointURL - Gets or sets the url of the service endpoint.
	EndpointURL *string `json:"endpointUrl,omitempty"`
	// Headers - Gets or sets the authorization headers.
	Headers *[]AuthorizationHeader `json:"headers,omitempty"`
	// InitialContextTemplate - Defines the initial value of the query params
	InitialContextTemplate *string `json:"initialContextTemplate,omitempty"`
	// Parameters - Gets or sets the parameters for the data source.
	Parameters map[string]*string `json:"parameters"`
	// RequestContent - Gets or sets http request body
	RequestContent *string `json:"requestContent,omitempty"`
	// RequestVerb - Gets or sets http request verb
	RequestVerb *string `json:"requestVerb,omitempty"`
	// ResultSelector - Gets or sets the result selector.
	ResultSelector *string `json:"resultSelector,omitempty"`
	// ResultTemplate - Gets or sets the result template.
	ResultTemplate *string `json:"resultTemplate,omitempty"`
	// Target - Gets or sets the target of the data source.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON is the custom marshaler for DataSourceBindingBase.
func (dsbb DataSourceBindingBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dsbb.CallbackContextTemplate != nil {
		objectMap["callbackContextTemplate"] = dsbb.CallbackContextTemplate
	}
	if dsbb.CallbackRequiredTemplate != nil {
		objectMap["callbackRequiredTemplate"] = dsbb.CallbackRequiredTemplate
	}
	if dsbb.DataSourceName != nil {
		objectMap["dataSourceName"] = dsbb.DataSourceName
	}
	if dsbb.EndpointID != nil {
		objectMap["endpointId"] = dsbb.EndpointID
	}
	if dsbb.EndpointURL != nil {
		objectMap["endpointUrl"] = dsbb.EndpointURL
	}
	if dsbb.Headers != nil {
		objectMap["headers"] = dsbb.Headers
	}
	if dsbb.InitialContextTemplate != nil {
		objectMap["initialContextTemplate"] = dsbb.InitialContextTemplate
	}
	if dsbb.Parameters != nil {
		objectMap["parameters"] = dsbb.Parameters
	}
	if dsbb.RequestContent != nil {
		objectMap["requestContent"] = dsbb.RequestContent
	}
	if dsbb.RequestVerb != nil {
		objectMap["requestVerb"] = dsbb.RequestVerb
	}
	if dsbb.ResultSelector != nil {
		objectMap["resultSelector"] = dsbb.ResultSelector
	}
	if dsbb.ResultTemplate != nil {
		objectMap["resultTemplate"] = dsbb.ResultTemplate
	}
	if dsbb.Target != nil {
		objectMap["target"] = dsbb.Target
	}
	return json.Marshal(objectMap)
}

// Definition represents a build definition.
type Definition struct {
	autorest.Response `json:"-"`
	// BadgeEnabled - Indicates whether badges are enabled for this definition.
	BadgeEnabled *bool `json:"badgeEnabled,omitempty"`
	// BuildNumberFormat - The build number format.
	BuildNumberFormat *string `json:"buildNumberFormat,omitempty"`
	// Comment - A save-time comment for the definition.
	Comment *string   `json:"comment,omitempty"`
	Demands *[]Demand `json:"demands,omitempty"`
	// Description - The description.
	Description *string `json:"description,omitempty"`
	// DropLocation - The drop location for the definition.
	DropLocation *string `json:"dropLocation,omitempty"`
	// JobAuthorizationScope - The job authorization scope for builds queued against this definition.
	JobAuthorizationScope interface{} `json:"jobAuthorizationScope,omitempty"`
	// JobCancelTimeoutInMinutes - The job cancel timeout (in minutes) for builds cancelled by user for this definition.
	JobCancelTimeoutInMinutes *int32 `json:"jobCancelTimeoutInMinutes,omitempty"`
	// JobTimeoutInMinutes - The job execution timeout (in minutes) for builds queued against this definition.
	JobTimeoutInMinutes *int32    `json:"jobTimeoutInMinutes,omitempty"`
	Options             *[]Option `json:"options,omitempty"`
	// Process - The build process.
	Process *Process `json:"process,omitempty"`
	// ProcessParameters - The process parameters for this definition.
	ProcessParameters *ProcessParameters    `json:"processParameters,omitempty"`
	Properties        *PropertiesCollection `json:"properties,omitempty"`
	// Repository - The repository.
	Repository     *Repository                    `json:"repository,omitempty"`
	RetentionRules *[]RetentionPolicy             `json:"retentionRules,omitempty"`
	Tags           *[]string                      `json:"tags,omitempty"`
	Triggers       *[]Trigger                     `json:"triggers,omitempty"`
	VariableGroups *[]VariableGroup               `json:"variableGroups,omitempty"`
	Variables      map[string]*DefinitionVariable `json:"variables"`
	Links          *ReferenceLinks                `json:"_links,omitempty"`
	// AuthoredBy - The author of the definition.
	AuthoredBy *IdentityRef `json:"authoredBy,omitempty"`
	// DraftOf - A reference to the definition that this definition is a draft of, if this is a draft definition.
	DraftOf *DefinitionReference `json:"draftOf,omitempty"`
	// Drafts - The list of drafts associated with this definition, if this is not a draft definition.
	Drafts               *[]DefinitionReference `json:"drafts,omitempty"`
	LatestBuild          *Model                 `json:"latestBuild,omitempty"`
	LatestCompletedBuild *Model                 `json:"latestCompletedBuild,omitempty"`
	Metrics              *[]Metric              `json:"metrics,omitempty"`
	// Quality - The quality of the definition document (draft, etc.)
	Quality interface{} `json:"quality,omitempty"`
	// Queue - The default queue for builds run against this definition.
	Queue *AgentPoolQueue `json:"queue,omitempty"`
	// CreatedDate - The date this version of the definition was created.
	CreatedDate *date.Time `json:"createdDate,omitempty"`
	// ID - The ID of the referenced definition.
	ID *int32 `json:"id,omitempty"`
	// Name - The name of the referenced definition.
	Name *string `json:"name,omitempty"`
	// Path - The folder path of the definition.
	Path *string `json:"path,omitempty"`
	// Project - A reference to the project.
	Project *TeamProjectReference `json:"project,omitempty"`
	// QueueStatus - A value that indicates whether builds can be queued against this definition.
	QueueStatus interface{} `json:"queueStatus,omitempty"`
	// Revision - The definition revision number.
	Revision *int32 `json:"revision,omitempty"`
	// Type - The type of the definition.
	Type interface{} `json:"type,omitempty"`
	// URI - The definition's URI.
	URI *string `json:"uri,omitempty"`
	// URL - The REST URL of the definition.
	URL *string `json:"url,omitempty"`
}

// MarshalJSON is the custom marshaler for Definition.
func (d Definition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.BadgeEnabled != nil {
		objectMap["badgeEnabled"] = d.BadgeEnabled
	}
	if d.BuildNumberFormat != nil {
		objectMap["buildNumberFormat"] = d.BuildNumberFormat
	}
	if d.Comment != nil {
		objectMap["comment"] = d.Comment
	}
	if d.Demands != nil {
		objectMap["demands"] = d.Demands
	}
	if d.Description != nil {
		objectMap["description"] = d.Description
	}
	if d.DropLocation != nil {
		objectMap["dropLocation"] = d.DropLocation
	}
	if d.JobAuthorizationScope != nil {
		objectMap["jobAuthorizationScope"] = d.JobAuthorizationScope
	}
	if d.JobCancelTimeoutInMinutes != nil {
		objectMap["jobCancelTimeoutInMinutes"] = d.JobCancelTimeoutInMinutes
	}
	if d.JobTimeoutInMinutes != nil {
		objectMap["jobTimeoutInMinutes"] = d.JobTimeoutInMinutes
	}
	if d.Options != nil {
		objectMap["options"] = d.Options
	}
	if d.Process != nil {
		objectMap["process"] = d.Process
	}

	/*if d.DockerProcess != nil {
		objectMap["process"] = d.DockerProcess
	}

	if d.YamlProcess != nil {
		objectMap["process"] = d.YamlProcess
	}*/

	if d.ProcessParameters != nil {
		objectMap["processParameters"] = d.ProcessParameters
	}
	if d.Properties != nil {
		objectMap["properties"] = d.Properties
	}
	if d.Repository != nil {
		objectMap["repository"] = d.Repository
	}
	if d.RetentionRules != nil {
		objectMap["retentionRules"] = d.RetentionRules
	}
	if d.Tags != nil {
		objectMap["tags"] = d.Tags
	}
	if d.Triggers != nil {
		objectMap["triggers"] = d.Triggers
	}
	if d.VariableGroups != nil {
		objectMap["variableGroups"] = d.VariableGroups
	}
	if d.Variables != nil {
		objectMap["variables"] = d.Variables
	}
	if d.Links != nil {
		objectMap["_links"] = d.Links
	}
	if d.AuthoredBy != nil {
		objectMap["authoredBy"] = d.AuthoredBy
	}
	if d.DraftOf != nil {
		objectMap["draftOf"] = d.DraftOf
	}
	if d.Drafts != nil {
		objectMap["drafts"] = d.Drafts
	}
	if d.LatestBuild != nil {
		objectMap["latestBuild"] = d.LatestBuild
	}
	if d.LatestCompletedBuild != nil {
		objectMap["latestCompletedBuild"] = d.LatestCompletedBuild
	}
	if d.Metrics != nil {
		objectMap["metrics"] = d.Metrics
	}
	if d.Quality != nil {
		objectMap["quality"] = d.Quality
	}
	if d.Queue != nil {
		objectMap["queue"] = d.Queue
	}
	if d.CreatedDate != nil {
		objectMap["createdDate"] = d.CreatedDate
	}
	if d.ID != nil {
		objectMap["id"] = d.ID
	}
	if d.Name != nil {
		objectMap["name"] = d.Name
	}
	if d.Path != nil {
		objectMap["path"] = d.Path
	}
	if d.Project != nil {
		objectMap["project"] = d.Project
	}
	if d.QueueStatus != nil {
		objectMap["queueStatus"] = d.QueueStatus
	}
	if d.Revision != nil {
		objectMap["revision"] = d.Revision
	}
	if d.Type != nil {
		objectMap["type"] = d.Type
	}
	if d.URI != nil {
		objectMap["uri"] = d.URI
	}
	if d.URL != nil {
		objectMap["url"] = d.URL
	}
	return json.Marshal(objectMap)
}

// Definition32 for back-compat with extensions that use the old Steps format instead of Process and Phases
type Definition32 struct {
	// BadgeEnabled - Indicates whether badges are enabled for this definition
	BadgeEnabled  *bool             `json:"badgeEnabled,omitempty"`
	BuildProperty *[]DefinitionStep `json:"build,omitempty"`
	// BuildNumberFormat - The build number format
	BuildNumberFormat *string `json:"buildNumberFormat,omitempty"`
	// Comment - The comment entered when saving the definition
	Comment *string   `json:"comment,omitempty"`
	Demands *[]Demand `json:"demands,omitempty"`
	// Description - The description
	Description *string `json:"description,omitempty"`
	// DropLocation - The drop location for the definition
	DropLocation *string `json:"dropLocation,omitempty"`
	// JobAuthorizationScope - The job authorization scope for builds which are queued against this definition
	JobAuthorizationScope interface{} `json:"jobAuthorizationScope,omitempty"`
	// JobCancelTimeoutInMinutes - The job cancel timeout in minutes for builds which are cancelled by user for this definition
	JobCancelTimeoutInMinutes *int32 `json:"jobCancelTimeoutInMinutes,omitempty"`
	// JobTimeoutInMinutes - The job execution timeout in minutes for builds which are queued against this definition
	JobTimeoutInMinutes  *int32    `json:"jobTimeoutInMinutes,omitempty"`
	LatestBuild          *Model    `json:"latestBuild,omitempty"`
	LatestCompletedBuild *Model    `json:"latestCompletedBuild,omitempty"`
	Options              *[]Option `json:"options,omitempty"`
	// ProcessParameters - Process Parameters
	ProcessParameters *ProcessParameters    `json:"processParameters,omitempty"`
	Properties        *PropertiesCollection `json:"properties,omitempty"`
	// Repository - The repository
	Repository     *Repository                    `json:"repository,omitempty"`
	RetentionRules *[]RetentionPolicy             `json:"retentionRules,omitempty"`
	Tags           *[]string                      `json:"tags,omitempty"`
	Triggers       *[]Trigger                     `json:"triggers,omitempty"`
	Variables      map[string]*DefinitionVariable `json:"variables"`
	Links          *ReferenceLinks                `json:"_links,omitempty"`
	// AuthoredBy - The author of the definition.
	AuthoredBy *IdentityRef `json:"authoredBy,omitempty"`
	// DraftOf - A reference to the definition that this definition is a draft of, if this is a draft definition.
	DraftOf *DefinitionReference `json:"draftOf,omitempty"`
	// Drafts - The list of drafts associated with this definition, if this is not a draft definition.
	Drafts  *[]DefinitionReference `json:"drafts,omitempty"`
	Metrics *[]Metric              `json:"metrics,omitempty"`
	// Quality - The quality of the definition document (draft, etc.)
	Quality interface{} `json:"quality,omitempty"`
	// Queue - The default queue for builds run against this definition.
	Queue *AgentPoolQueue `json:"queue,omitempty"`
	// CreatedDate - The date this version of the definition was created.
	CreatedDate *date.Time `json:"createdDate,omitempty"`
	// ID - The ID of the referenced definition.
	ID *int32 `json:"id,omitempty"`
	// Name - The name of the referenced definition.
	Name *string `json:"name,omitempty"`
	// Path - The folder path of the definition.
	Path *string `json:"path,omitempty"`
	// Project - A reference to the project.
	Project *TeamProjectReference `json:"project,omitempty"`
	// QueueStatus - A value that indicates whether builds can be queued against this definition.
	QueueStatus interface{} `json:"queueStatus,omitempty"`
	// Revision - The definition revision number.
	Revision *int32 `json:"revision,omitempty"`
	// Type - The type of the definition.
	Type interface{} `json:"type,omitempty"`
	// URI - The definition's URI.
	URI *string `json:"uri,omitempty"`
	// URL - The REST URL of the definition.
	URL *string `json:"url,omitempty"`
}

// MarshalJSON is the custom marshaler for Definition32.
func (d3 Definition32) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d3.BadgeEnabled != nil {
		objectMap["badgeEnabled"] = d3.BadgeEnabled
	}
	if d3.BuildProperty != nil {
		objectMap["build"] = d3.BuildProperty
	}
	if d3.BuildNumberFormat != nil {
		objectMap["buildNumberFormat"] = d3.BuildNumberFormat
	}
	if d3.Comment != nil {
		objectMap["comment"] = d3.Comment
	}
	if d3.Demands != nil {
		objectMap["demands"] = d3.Demands
	}
	if d3.Description != nil {
		objectMap["description"] = d3.Description
	}
	if d3.DropLocation != nil {
		objectMap["dropLocation"] = d3.DropLocation
	}
	if d3.JobAuthorizationScope != nil {
		objectMap["jobAuthorizationScope"] = d3.JobAuthorizationScope
	}
	if d3.JobCancelTimeoutInMinutes != nil {
		objectMap["jobCancelTimeoutInMinutes"] = d3.JobCancelTimeoutInMinutes
	}
	if d3.JobTimeoutInMinutes != nil {
		objectMap["jobTimeoutInMinutes"] = d3.JobTimeoutInMinutes
	}
	if d3.LatestBuild != nil {
		objectMap["latestBuild"] = d3.LatestBuild
	}
	if d3.LatestCompletedBuild != nil {
		objectMap["latestCompletedBuild"] = d3.LatestCompletedBuild
	}
	if d3.Options != nil {
		objectMap["options"] = d3.Options
	}
	if d3.ProcessParameters != nil {
		objectMap["processParameters"] = d3.ProcessParameters
	}
	if d3.Properties != nil {
		objectMap["properties"] = d3.Properties
	}
	if d3.Repository != nil {
		objectMap["repository"] = d3.Repository
	}
	if d3.RetentionRules != nil {
		objectMap["retentionRules"] = d3.RetentionRules
	}
	if d3.Tags != nil {
		objectMap["tags"] = d3.Tags
	}
	if d3.Triggers != nil {
		objectMap["triggers"] = d3.Triggers
	}
	if d3.Variables != nil {
		objectMap["variables"] = d3.Variables
	}
	if d3.Links != nil {
		objectMap["_links"] = d3.Links
	}
	if d3.AuthoredBy != nil {
		objectMap["authoredBy"] = d3.AuthoredBy
	}
	if d3.DraftOf != nil {
		objectMap["draftOf"] = d3.DraftOf
	}
	if d3.Drafts != nil {
		objectMap["drafts"] = d3.Drafts
	}
	if d3.Metrics != nil {
		objectMap["metrics"] = d3.Metrics
	}
	if d3.Quality != nil {
		objectMap["quality"] = d3.Quality
	}
	if d3.Queue != nil {
		objectMap["queue"] = d3.Queue
	}
	if d3.CreatedDate != nil {
		objectMap["createdDate"] = d3.CreatedDate
	}
	if d3.ID != nil {
		objectMap["id"] = d3.ID
	}
	if d3.Name != nil {
		objectMap["name"] = d3.Name
	}
	if d3.Path != nil {
		objectMap["path"] = d3.Path
	}
	if d3.Project != nil {
		objectMap["project"] = d3.Project
	}
	if d3.QueueStatus != nil {
		objectMap["queueStatus"] = d3.QueueStatus
	}
	if d3.Revision != nil {
		objectMap["revision"] = d3.Revision
	}
	if d3.Type != nil {
		objectMap["type"] = d3.Type
	}
	if d3.URI != nil {
		objectMap["uri"] = d3.URI
	}
	if d3.URL != nil {
		objectMap["url"] = d3.URL
	}
	return json.Marshal(objectMap)
}

// DefinitionReference represents a reference to a definition.
type DefinitionReference struct {
	// CreatedDate - The date this version of the definition was created.
	CreatedDate *date.Time `json:"createdDate,omitempty"`
	// ID - The ID of the referenced definition.
	ID *int32 `json:"id,omitempty"`
	// Name - The name of the referenced definition.
	Name *string `json:"name,omitempty"`
	// Path - The folder path of the definition.
	Path *string `json:"path,omitempty"`
	// Project - A reference to the project.
	Project *TeamProjectReference `json:"project,omitempty"`
	// QueueStatus - A value that indicates whether builds can be queued against this definition.
	QueueStatus interface{} `json:"queueStatus,omitempty"`
	// Revision - The definition revision number.
	Revision *int32 `json:"revision,omitempty"`
	// Type - The type of the definition.
	Type interface{} `json:"type,omitempty"`
	// URI - The definition's URI.
	URI *string `json:"uri,omitempty"`
	// URL - The REST URL of the definition.
	URL *string `json:"url,omitempty"`
}

// DefinitionReference32 for back-compat with extensions that use the old Steps format instead of Process
// and Phases
type DefinitionReference32 struct {
	Links *ReferenceLinks `json:"_links,omitempty"`
	// AuthoredBy - The author of the definition.
	AuthoredBy *IdentityRef `json:"authoredBy,omitempty"`
	// DraftOf - A reference to the definition that this definition is a draft of, if this is a draft definition.
	DraftOf *DefinitionReference `json:"draftOf,omitempty"`
	// Drafts - The list of drafts associated with this definition, if this is not a draft definition.
	Drafts  *[]DefinitionReference `json:"drafts,omitempty"`
	Metrics *[]Metric              `json:"metrics,omitempty"`
	// Quality - The quality of the definition document (draft, etc.)
	Quality interface{} `json:"quality,omitempty"`
	// Queue - The default queue for builds run against this definition.
	Queue *AgentPoolQueue `json:"queue,omitempty"`
	// CreatedDate - The date this version of the definition was created.
	CreatedDate *date.Time `json:"createdDate,omitempty"`
	// ID - The ID of the referenced definition.
	ID *int32 `json:"id,omitempty"`
	// Name - The name of the referenced definition.
	Name *string `json:"name,omitempty"`
	// Path - The folder path of the definition.
	Path *string `json:"path,omitempty"`
	// Project - A reference to the project.
	Project *TeamProjectReference `json:"project,omitempty"`
	// QueueStatus - A value that indicates whether builds can be queued against this definition.
	QueueStatus interface{} `json:"queueStatus,omitempty"`
	// Revision - The definition revision number.
	Revision *int32 `json:"revision,omitempty"`
	// Type - The type of the definition.
	Type interface{} `json:"type,omitempty"`
	// URI - The definition's URI.
	URI *string `json:"uri,omitempty"`
	// URL - The REST URL of the definition.
	URL *string `json:"url,omitempty"`
}

// DefinitionReferenceType represents a reference to a build definition.
type DefinitionReferenceType struct {
	Links *ReferenceLinks `json:"_links,omitempty"`
	// AuthoredBy - The author of the definition.
	AuthoredBy *IdentityRef `json:"authoredBy,omitempty"`
	// DraftOf - A reference to the definition that this definition is a draft of, if this is a draft definition.
	DraftOf *DefinitionReference `json:"draftOf,omitempty"`
	// Drafts - The list of drafts associated with this definition, if this is not a draft definition.
	Drafts               *[]DefinitionReference `json:"drafts,omitempty"`
	LatestBuild          *Model                 `json:"latestBuild,omitempty"`
	LatestCompletedBuild *Model                 `json:"latestCompletedBuild,omitempty"`
	Metrics              *[]Metric              `json:"metrics,omitempty"`
	// Quality - The quality of the definition document (draft, etc.)
	Quality interface{} `json:"quality,omitempty"`
	// Queue - The default queue for builds run against this definition.
	Queue *AgentPoolQueue `json:"queue,omitempty"`
	// CreatedDate - The date this version of the definition was created.
	CreatedDate *date.Time `json:"createdDate,omitempty"`
	// ID - The ID of the referenced definition.
	ID *int32 `json:"id,omitempty"`
	// Name - The name of the referenced definition.
	Name *string `json:"name,omitempty"`
	// Path - The folder path of the definition.
	Path *string `json:"path,omitempty"`
	// Project - A reference to the project.
	Project *TeamProjectReference `json:"project,omitempty"`
	// QueueStatus - A value that indicates whether builds can be queued against this definition.
	QueueStatus interface{} `json:"queueStatus,omitempty"`
	// Revision - The definition revision number.
	Revision *int32 `json:"revision,omitempty"`
	// Type - The type of the definition.
	Type interface{} `json:"type,omitempty"`
	// URI - The definition's URI.
	URI *string `json:"uri,omitempty"`
	// URL - The REST URL of the definition.
	URL *string `json:"url,omitempty"`
}

// DefinitionResourceReference ...
type DefinitionResourceReference struct {
	// Authorized - Indicates whether the resource is authorized for use.
	Authorized *bool `json:"authorized,omitempty"`
	// ID - The id of the resource.
	ID *string `json:"id,omitempty"`
	// Name - A friendly name for the resource.
	Name *string `json:"name,omitempty"`
	// Type - The type of the resource.
	Type *string `json:"type,omitempty"`
}

// DefinitionRevision represents a revision of a build definition.
type DefinitionRevision struct {
	// ChangedBy - The identity of the person or process that changed the definition.
	ChangedBy *IdentityRef `json:"changedBy,omitempty"`
	// ChangedDate - The date and time that the definition was changed.
	ChangedDate *date.Time `json:"changedDate,omitempty"`
	// ChangeType - The change type (add, edit, delete).
	ChangeType interface{} `json:"changeType,omitempty"`
	// Comment - The comment associated with the change.
	Comment *string `json:"comment,omitempty"`
	// DefinitionURL - A link to the definition at this revision.
	DefinitionURL *string `json:"definitionUrl,omitempty"`
	// Name - The name of the definition.
	Name *string `json:"name,omitempty"`
	// Revision - The revision number.
	Revision *int32 `json:"revision,omitempty"`
}

// DefinitionSourceProvider ...
type DefinitionSourceProvider struct {
	// DefinitionURI - Uri of the associated definition
	DefinitionURI *string `json:"definitionUri,omitempty"`
	// Fields - fields associated with this build definition
	Fields map[string]*string `json:"fields"`
	// ID - Id of this source provider
	ID *int32 `json:"id,omitempty"`
	// LastModified - The lst time this source provider was modified
	LastModified *date.Time `json:"lastModified,omitempty"`
	// Name - Name of the source provider
	Name *string `json:"name,omitempty"`
	// SupportedTriggerTypes - Which trigger types are supported by this definition source provider
	SupportedTriggerTypes interface{} `json:"supportedTriggerTypes,omitempty"`
}

// MarshalJSON is the custom marshaler for DefinitionSourceProvider.
func (dsp DefinitionSourceProvider) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dsp.DefinitionURI != nil {
		objectMap["definitionUri"] = dsp.DefinitionURI
	}
	if dsp.Fields != nil {
		objectMap["fields"] = dsp.Fields
	}
	if dsp.ID != nil {
		objectMap["id"] = dsp.ID
	}
	if dsp.LastModified != nil {
		objectMap["lastModified"] = dsp.LastModified
	}
	if dsp.Name != nil {
		objectMap["name"] = dsp.Name
	}
	if dsp.SupportedTriggerTypes != nil {
		objectMap["supportedTriggerTypes"] = dsp.SupportedTriggerTypes
	}
	return json.Marshal(objectMap)
}

// DefinitionStep represents a step in a build phase.
type DefinitionStep struct {
	// AlwaysRun - Indicates whether this step should run even if a previous step fails.
	AlwaysRun *bool `json:"alwaysRun,omitempty"`
	// Condition - A condition that determines whether this step should run.
	Condition *string `json:"condition,omitempty"`
	// ContinueOnError - Indicates whether the phase should continue even if this step fails.
	ContinueOnError *bool `json:"continueOnError,omitempty"`
	// DisplayName - The display name for this step.
	DisplayName *string `json:"displayName,omitempty"`
	// Enabled - Indicates whether the step is enabled.
	Enabled     *bool              `json:"enabled,omitempty"`
	Environment map[string]*string `json:"environment"`
	Inputs      map[string]*string `json:"inputs"`
	// RefName - The reference name for this step.
	RefName *string `json:"refName,omitempty"`
	// Task - The task associated with this step.
	Task *TaskDefinitionReference `json:"task,omitempty"`
	// TimeoutInMinutes - The time, in minutes, that this step is allowed to run.
	TimeoutInMinutes *int32 `json:"timeoutInMinutes,omitempty"`
}

// MarshalJSON is the custom marshaler for DefinitionStep.
func (ds DefinitionStep) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ds.AlwaysRun != nil {
		objectMap["alwaysRun"] = ds.AlwaysRun
	}
	if ds.Condition != nil {
		objectMap["condition"] = ds.Condition
	}
	if ds.ContinueOnError != nil {
		objectMap["continueOnError"] = ds.ContinueOnError
	}
	if ds.DisplayName != nil {
		objectMap["displayName"] = ds.DisplayName
	}
	if ds.Enabled != nil {
		objectMap["enabled"] = ds.Enabled
	}
	if ds.Environment != nil {
		objectMap["environment"] = ds.Environment
	}
	if ds.Inputs != nil {
		objectMap["inputs"] = ds.Inputs
	}
	if ds.RefName != nil {
		objectMap["refName"] = ds.RefName
	}
	if ds.Task != nil {
		objectMap["task"] = ds.Task
	}
	if ds.TimeoutInMinutes != nil {
		objectMap["timeoutInMinutes"] = ds.TimeoutInMinutes
	}
	return json.Marshal(objectMap)
}

// DefinitionTemplate represents a template from which new build definitions can be created.
type DefinitionTemplate struct {
	autorest.Response `json:"-"`
	// CanDelete - Indicates whether the template can be deleted.
	CanDelete *bool `json:"canDelete,omitempty"`
	// Category - The template category.
	Category *string `json:"category,omitempty"`
	// DefaultHostedQueue - An optional hosted agent queue for the template to use by default.
	DefaultHostedQueue *string `json:"defaultHostedQueue,omitempty"`
	// Description - A description of the template.
	Description *string            `json:"description,omitempty"`
	Icons       map[string]*string `json:"icons"`
	// IconTaskID - The ID of the task whose icon is used when showing this template in the UI.
	IconTaskID *uuid.UUID `json:"iconTaskId,omitempty"`
	// ID - The ID of the template.
	ID *string `json:"id,omitempty"`
	// Name - The name of the template.
	Name *string `json:"name,omitempty"`
	// Template - The actual template.
	Template *Definition `json:"template,omitempty"`
}

// MarshalJSON is the custom marshaler for DefinitionTemplate.
func (dt DefinitionTemplate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dt.CanDelete != nil {
		objectMap["canDelete"] = dt.CanDelete
	}
	if dt.Category != nil {
		objectMap["category"] = dt.Category
	}
	if dt.DefaultHostedQueue != nil {
		objectMap["defaultHostedQueue"] = dt.DefaultHostedQueue
	}
	if dt.Description != nil {
		objectMap["description"] = dt.Description
	}
	if dt.Icons != nil {
		objectMap["icons"] = dt.Icons
	}
	if dt.IconTaskID != nil {
		objectMap["iconTaskId"] = dt.IconTaskID
	}
	if dt.ID != nil {
		objectMap["id"] = dt.ID
	}
	if dt.Name != nil {
		objectMap["name"] = dt.Name
	}
	if dt.Template != nil {
		objectMap["template"] = dt.Template
	}
	return json.Marshal(objectMap)
}

// DefinitionTemplate32 for back-compat with extensions that use the old Steps format instead of Process
// and Phases
type DefinitionTemplate32 struct {
	CanDelete          *bool              `json:"canDelete,omitempty"`
	Category           *string            `json:"category,omitempty"`
	DefaultHostedQueue *string            `json:"defaultHostedQueue,omitempty"`
	Description        *string            `json:"description,omitempty"`
	Icons              map[string]*string `json:"icons"`
	IconTaskID         *uuid.UUID         `json:"iconTaskId,omitempty"`
	ID                 *string            `json:"id,omitempty"`
	Name               *string            `json:"name,omitempty"`
	Template           *Definition32      `json:"template,omitempty"`
}

// MarshalJSON is the custom marshaler for DefinitionTemplate32.
func (dt3 DefinitionTemplate32) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dt3.CanDelete != nil {
		objectMap["canDelete"] = dt3.CanDelete
	}
	if dt3.Category != nil {
		objectMap["category"] = dt3.Category
	}
	if dt3.DefaultHostedQueue != nil {
		objectMap["defaultHostedQueue"] = dt3.DefaultHostedQueue
	}
	if dt3.Description != nil {
		objectMap["description"] = dt3.Description
	}
	if dt3.Icons != nil {
		objectMap["icons"] = dt3.Icons
	}
	if dt3.IconTaskID != nil {
		objectMap["iconTaskId"] = dt3.IconTaskID
	}
	if dt3.ID != nil {
		objectMap["id"] = dt3.ID
	}
	if dt3.Name != nil {
		objectMap["name"] = dt3.Name
	}
	if dt3.Template != nil {
		objectMap["template"] = dt3.Template
	}
	return json.Marshal(objectMap)
}

// DefinitionVariable represents a variable used by a build definition.
type DefinitionVariable struct {
	// AllowOverride - Indicates whether the value can be set at queue time.
	AllowOverride *bool `json:"allowOverride,omitempty"`
	// IsSecret - Indicates whether the variable's value is a secret.
	IsSecret *bool `json:"isSecret,omitempty"`
	// Value - The value of the variable.
	Value *string `json:"value,omitempty"`
}

// DeletedEvent ...
type DeletedEvent struct {
	BuildProperty *Model `json:"build,omitempty"`
	BuildID       *int32 `json:"buildId,omitempty"`
}

// Demand represents a demand used by a definition or build.
type Demand struct {
	// Name - The name of the capability referenced by the demand.
	Name *string `json:"name,omitempty"`
	// Value - The demanded value.
	Value *string `json:"value,omitempty"`
}

// Dependency represents a dependency.
type Dependency struct {
	// Event - The event. The dependency is satisfied when the referenced object emits this event.
	Event *string `json:"event,omitempty"`
	// Scope - The scope. This names the object referenced by the dependency.
	Scope *string `json:"scope,omitempty"`
}

// Deployment represents the data from the build information nodes for type "DeploymentInformation" for
// xaml builds
type Deployment struct {
	Type *string `json:"type,omitempty"`
}

// DeploymentBuild deployment information for type "Build"
type DeploymentBuild struct {
	BuildID *int32  `json:"buildId,omitempty"`
	Type    *string `json:"type,omitempty"`
}

// DeploymentDeploy deployment information for type "Deploy"
type DeploymentDeploy struct {
	Message *string `json:"message,omitempty"`
	Type    *string `json:"type,omitempty"`
}

// DeploymentTest deployment information for type "Test"
type DeploymentTest struct {
	RunID *int32  `json:"runId,omitempty"`
	Type  *string `json:"type,omitempty"`
}

// DeploymentType ...
type DeploymentType struct {
	Deployment  *Summary            `json:"deployment,omitempty"`
	SourceBuild *XamlBuildReference `json:"sourceBuild,omitempty"`
}

// DesignerProcess represents a build process supported by the build definition designer.
type DesignerProcess struct {
	Phases *[]Phase `json:"phases,omitempty"`
	// Target - The target for the build process.
	Target *DesignerProcessTarget `json:"target,omitempty"`
	// Type - The type of the process.
	Type *int32 `json:"type,omitempty"`
}

// DesignerProcessTarget represents the target for the build process.
type DesignerProcessTarget struct {
	// AgentSpecification - Agent specification for the build process.
	AgentSpecification *AgentSpecification `json:"agentSpecification,omitempty"`
}

// DockerProcess ...
type DockerProcess struct {
	// Type - The type of the process.
	Type *int32 `json:"type,omitempty"`
}

// Event ...
type Event struct {
	Data       *[]string `json:"data,omitempty"`
	Identifier *string   `json:"identifier,omitempty"`
}

// Folder represents a folder that contains build definitions.
type Folder struct {
	autorest.Response `json:"-"`
	// CreatedBy - The process or person who created the folder.
	CreatedBy *IdentityRef `json:"createdBy,omitempty"`
	// CreatedOn - The date the folder was created.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// Description - The description.
	Description *string `json:"description,omitempty"`
	// LastChangedBy - The process or person that last changed the folder.
	LastChangedBy *IdentityRef `json:"lastChangedBy,omitempty"`
	// LastChangedDate - The date the folder was last changed.
	LastChangedDate *date.Time `json:"lastChangedDate,omitempty"`
	// Path - The full path.
	Path *string `json:"path,omitempty"`
	// Project - The project.
	Project *TeamProjectReference `json:"project,omitempty"`
}

// Forks represents the ability to build forks of the selected repository.
type Forks struct {
	// AllowSecrets - Indicates whether a build should use secrets when building forks of the selected repository.
	AllowSecrets *bool `json:"allowSecrets,omitempty"`
	// Enabled - Indicates whether the trigger should queue builds for forks of the selected repository.
	Enabled *bool `json:"enabled,omitempty"`
}

// GatedCheckInTrigger represents a gated check-in trigger.
type GatedCheckInTrigger struct {
	PathFilters *[]string `json:"pathFilters,omitempty"`
	// RunContinuousIntegration - Indicates whether CI triggers should run after the gated check-in succeeds.
	RunContinuousIntegration *bool `json:"runContinuousIntegration,omitempty"`
	// UseWorkspaceMappings - Indicates whether to take workspace mappings into account when determining whether a build should run.
	UseWorkspaceMappings *bool `json:"useWorkspaceMappings,omitempty"`
	// TriggerType - The type of the trigger.
	TriggerType interface{} `json:"triggerType,omitempty"`
}

// GraphSubjectBase ...
type GraphSubjectBase struct {
	// Links - This field contains zero or more interesting links about the graph subject. These links may be invoked to obtain additional relationships or more detailed information about this graph subject.
	Links *ReferenceLinks `json:"_links,omitempty"`
	// Descriptor - The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
	Descriptor *string `json:"descriptor,omitempty"`
	// DisplayName - This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
	DisplayName *string `json:"displayName,omitempty"`
	// URL - This url is the full route to the source resource of this graph subject.
	URL *string `json:"url,omitempty"`
}

// IdentityRef ...
type IdentityRef struct {
	// DirectoryAlias - Deprecated - Can be retrieved by querying the Graph user referenced in the "self" entry of the IdentityRef "_links" dictionary
	DirectoryAlias *string `json:"directoryAlias,omitempty"`
	ID             *string `json:"id,omitempty"`
	// ImageURL - Deprecated - Available in the "avatar" entry of the IdentityRef "_links" dictionary
	ImageURL *string `json:"imageUrl,omitempty"`
	// Inactive - Deprecated - Can be retrieved by querying the Graph membership state referenced in the "membershipState" entry of the GraphUser "_links" dictionary
	Inactive *bool `json:"inactive,omitempty"`
	// IsAadIdentity - Deprecated - Can be inferred from the subject type of the descriptor (Descriptor.IsAadUserType/Descriptor.IsAadGroupType)
	IsAadIdentity *bool `json:"isAadIdentity,omitempty"`
	// IsContainer - Deprecated - Can be inferred from the subject type of the descriptor (Descriptor.IsGroupType)
	IsContainer       *bool `json:"isContainer,omitempty"`
	IsDeletedInOrigin *bool `json:"isDeletedInOrigin,omitempty"`
	// ProfileURL - Deprecated - not in use in most preexisting implementations of ToIdentityRef
	ProfileURL *string `json:"profileUrl,omitempty"`
	// UniqueName - Deprecated - use Domain+PrincipalName instead
	UniqueName *string `json:"uniqueName,omitempty"`
	// Links - This field contains zero or more interesting links about the graph subject. These links may be invoked to obtain additional relationships or more detailed information about this graph subject.
	Links *ReferenceLinks `json:"_links,omitempty"`
	// Descriptor - The descriptor is the primary way to reference the graph subject while the system is running. This field will uniquely identify the same graph subject across both Accounts and Organizations.
	Descriptor *string `json:"descriptor,omitempty"`
	// DisplayName - This is the non-unique display name of the graph subject. To change this field, you must alter its value in the source provider.
	DisplayName *string `json:"displayName,omitempty"`
	// URL - This url is the full route to the source resource of this graph subject.
	URL *string `json:"url,omitempty"`
}

// InformationNode data representation of an information node associated with a build
type InformationNode struct {
	// Fields - Fields of the information node
	Fields map[string]*string `json:"fields"`
	// LastModifiedBy - Process or person that last modified this node
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedDate - Date this node was last modified
	LastModifiedDate *date.Time `json:"lastModifiedDate,omitempty"`
	// NodeID - Node Id of this information node
	NodeID *int32 `json:"nodeId,omitempty"`
	// ParentID - Id of parent node (xml tree)
	ParentID *int32 `json:"parentId,omitempty"`
	// Type - The type of the information node
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for InformationNode.
func (in InformationNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if in.Fields != nil {
		objectMap["fields"] = in.Fields
	}
	if in.LastModifiedBy != nil {
		objectMap["lastModifiedBy"] = in.LastModifiedBy
	}
	if in.LastModifiedDate != nil {
		objectMap["lastModifiedDate"] = in.LastModifiedDate
	}
	if in.NodeID != nil {
		objectMap["nodeId"] = in.NodeID
	}
	if in.ParentID != nil {
		objectMap["parentId"] = in.ParentID
	}
	if in.Type != nil {
		objectMap["type"] = in.Type
	}
	return json.Marshal(objectMap)
}

// Issue represents an issue (error, warning) associated with a build.
type Issue struct {
	// Category - The category.
	Category *string            `json:"category,omitempty"`
	Data     map[string]*string `json:"data"`
	// Message - A description of the issue.
	Message *string `json:"message,omitempty"`
	// Type - The type (error, warning) of the issue.
	Type interface{} `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Issue.
func (i Issue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.Category != nil {
		objectMap["category"] = i.Category
	}
	if i.Data != nil {
		objectMap["data"] = i.Data
	}
	if i.Message != nil {
		objectMap["message"] = i.Message
	}
	if i.Type != nil {
		objectMap["type"] = i.Type
	}
	return json.Marshal(objectMap)
}

// JSONPatchOperation the JSON model for a JSON Patch operation
type JSONPatchOperation struct {
	// From - The path to copy from for the Move/Copy operation.
	From *string `json:"from,omitempty"`
	// Op - The patch operation
	Op interface{} `json:"op,omitempty"`
	// Path - The path for the operation
	Path *string `json:"path,omitempty"`
	// Value - The value for the operation. This is either a primitive or a JToken.
	Value interface{} `json:"value,omitempty"`
}

// ListArtifact ...
type ListArtifact struct {
	autorest.Response `json:"-"`
	Value             *[]Artifact `json:"value,omitempty"`
}

// ListAttachment ...
type ListAttachment struct {
	autorest.Response `json:"-"`
	Value             *[]Attachment `json:"value,omitempty"`
}

// ListChange ...
type ListChange struct {
	autorest.Response `json:"-"`
	Value             *[]Change `json:"value,omitempty"`
}

// ListController ...
type ListController struct {
	autorest.Response `json:"-"`
	Value             *[]Controller `json:"value,omitempty"`
}

// ListDefinitionReferenceType ...
type ListDefinitionReferenceType struct {
	autorest.Response `json:"-"`
	Value             *[]DefinitionReferenceType `json:"value,omitempty"`
}

// ListDefinitionResourceReference ...
type ListDefinitionResourceReference struct {
	autorest.Response `json:"-"`
	Value             *[]DefinitionResourceReference `json:"value,omitempty"`
}

// ListDefinitionRevision ...
type ListDefinitionRevision struct {
	autorest.Response `json:"-"`
	Value             *[]DefinitionRevision `json:"value,omitempty"`
}

// ListDefinitionTemplate ...
type ListDefinitionTemplate struct {
	autorest.Response `json:"-"`
	Value             *[]DefinitionTemplate `json:"value,omitempty"`
}

// ListFolder ...
type ListFolder struct {
	autorest.Response `json:"-"`
	Value             *[]Folder `json:"value,omitempty"`
}

// ListLog ...
type ListLog struct {
	autorest.Response `json:"-"`
	Value             *[]Log `json:"value,omitempty"`
}

// ListMetric ...
type ListMetric struct {
	autorest.Response `json:"-"`
	Value             *[]Metric `json:"value,omitempty"`
}

// ListModel ...
type ListModel struct {
	autorest.Response `json:"-"`
	Value             *[]Model `json:"value,omitempty"`
}

// ListOptionDefinition ...
type ListOptionDefinition struct {
	autorest.Response `json:"-"`
	Value             *[]OptionDefinition `json:"value,omitempty"`
}

// ListRepositoryWebhook ...
type ListRepositoryWebhook struct {
	autorest.Response `json:"-"`
	Value             *[]RepositoryWebhook `json:"value,omitempty"`
}

// ListResourceRef ...
type ListResourceRef struct {
	autorest.Response `json:"-"`
	Value             *[]ResourceRef `json:"value,omitempty"`
}

// ListSourceProviderAttributes ...
type ListSourceProviderAttributes struct {
	autorest.Response `json:"-"`
	Value             *[]SourceProviderAttributes `json:"value,omitempty"`
}

// ListSourceRepositoryItem ...
type ListSourceRepositoryItem struct {
	autorest.Response `json:"-"`
	Value             *[]SourceRepositoryItem `json:"value,omitempty"`
}

// ListString ...
type ListString struct {
	autorest.Response `json:"-"`
	Value             *[]string `json:"value,omitempty"`
}

// Log represents a build log.
type Log struct {
	// CreatedOn - The date and time the log was created.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// LastChangedOn - The date and time the log was last changed.
	LastChangedOn *date.Time `json:"lastChangedOn,omitempty"`
	// LineCount - The number of lines in the log.
	LineCount *int64 `json:"lineCount,omitempty"`
	// ID - The ID of the log.
	ID *int32 `json:"id,omitempty"`
	// Type - The type of the log location.
	Type *string `json:"type,omitempty"`
	// URL - A full link to the log resource.
	URL *string `json:"url,omitempty"`
}

// LogReference represents a reference to a build log.
type LogReference struct {
	// ID - The ID of the log.
	ID *int32 `json:"id,omitempty"`
	// Type - The type of the log location.
	Type *string `json:"type,omitempty"`
	// URL - A full link to the log resource.
	URL *string `json:"url,omitempty"`
}

// MappingDetails represents an entry in a workspace mapping.
type MappingDetails struct {
	// LocalPath - The local path.
	LocalPath *string `json:"localPath,omitempty"`
	// MappingType - The mapping type.
	MappingType *string `json:"mappingType,omitempty"`
	// ServerPath - The server path.
	ServerPath *string `json:"serverPath,omitempty"`
}

// Metric represents metadata about builds in the system.
type Metric struct {
	// Date - The date for the scope.
	Date *date.Time `json:"date,omitempty"`
	// IntValue - The value.
	IntValue *int32 `json:"intValue,omitempty"`
	// Name - The name of the metric.
	Name *string `json:"name,omitempty"`
	// Scope - The scope.
	Scope *string `json:"scope,omitempty"`
}

// Model data representation of a build.
type Model struct {
	autorest.Response `json:"-"`
	Links             *ReferenceLinks `json:"_links,omitempty"`
	// BuildNumber - The build number/name of the build.
	BuildNumber *string `json:"buildNumber,omitempty"`
	// BuildNumberRevision - The build number revision.
	BuildNumberRevision *int32 `json:"buildNumberRevision,omitempty"`
	// Controller - The build controller. This is only set if the definition type is Xaml.
	Controller *Controller `json:"controller,omitempty"`
	// Definition - The definition associated with the build.
	Definition *DefinitionReference `json:"definition,omitempty"`
	// Deleted - Indicates whether the build has been deleted.
	Deleted *bool `json:"deleted,omitempty"`
	// DeletedBy - The identity of the process or person that deleted the build.
	DeletedBy *IdentityRef `json:"deletedBy,omitempty"`
	// DeletedDate - The date the build was deleted.
	DeletedDate *date.Time `json:"deletedDate,omitempty"`
	// DeletedReason - The description of how the build was deleted.
	DeletedReason *string `json:"deletedReason,omitempty"`
	// Demands - A list of demands that represents the agent capabilities required by this build.
	Demands *[]Demand `json:"demands,omitempty"`
	// FinishTime - The time that the build was completed.
	FinishTime *date.Time `json:"finishTime,omitempty"`
	// ID - The ID of the build.
	ID *int32 `json:"id,omitempty"`
	// KeepForever - Indicates whether the build should be skipped by retention policies.
	KeepForever *bool `json:"keepForever,omitempty"`
	// LastChangedBy - The identity representing the process or person that last changed the build.
	LastChangedBy *IdentityRef `json:"lastChangedBy,omitempty"`
	// LastChangedDate - The date the build was last changed.
	LastChangedDate *date.Time `json:"lastChangedDate,omitempty"`
	// Logs - Information about the build logs.
	Logs *LogReference `json:"logs,omitempty"`
	// OrchestrationPlan - The orchestration plan for the build.
	OrchestrationPlan *TaskOrchestrationPlanReference `json:"orchestrationPlan,omitempty"`
	// Parameters - The parameters for the build.
	Parameters *string `json:"parameters,omitempty"`
	// Plans - Orchestration plans associated with the build (build, cleanup)
	Plans *[]TaskOrchestrationPlanReference `json:"plans,omitempty"`
	// Priority - The build's priority.
	Priority interface{} `json:"priority,omitempty"`
	// Project - The team project.
	Project    *TeamProjectReference `json:"project,omitempty"`
	Properties *PropertiesCollection `json:"properties,omitempty"`
	// Quality - The quality of the xaml build (good, bad, etc.)
	Quality *string `json:"quality,omitempty"`
	// Queue - The queue. This is only set if the definition type is Build.
	Queue *AgentPoolQueue `json:"queue,omitempty"`
	// QueueOptions - Additional options for queueing the build.
	QueueOptions interface{} `json:"queueOptions,omitempty"`
	// QueuePosition - The current position of the build in the queue.
	QueuePosition *int32 `json:"queuePosition,omitempty"`
	// QueueTime - The time that the build was queued.
	QueueTime *date.Time `json:"queueTime,omitempty"`
	// Reason - The reason that the build was created.
	Reason interface{} `json:"reason,omitempty"`
	// Repository - The repository.
	Repository *Repository `json:"repository,omitempty"`
	// RequestedBy - The identity that queued the build.
	RequestedBy *IdentityRef `json:"requestedBy,omitempty"`
	// RequestedFor - The identity on whose behalf the build was queued.
	RequestedFor *IdentityRef `json:"requestedFor,omitempty"`
	// Result - The build result.
	Result interface{} `json:"result,omitempty"`
	// RetainedByRelease - Indicates whether the build is retained by a release.
	RetainedByRelease *bool `json:"retainedByRelease,omitempty"`
	// SourceBranch - The source branch.
	SourceBranch *string `json:"sourceBranch,omitempty"`
	// SourceVersion - The source version.
	SourceVersion *string `json:"sourceVersion,omitempty"`
	// StartTime - The time that the build was started.
	StartTime *date.Time `json:"startTime,omitempty"`
	// Status - The status of the build.
	Status interface{} `json:"status,omitempty"`
	Tags   *[]string   `json:"tags,omitempty"`
	// TriggeredByBuild - The build that triggered this build via a Build completion trigger.
	TriggeredByBuild *Model `json:"triggeredByBuild,omitempty"`
	// TriggerInfo - Sourceprovider-specific information about what triggered the build
	TriggerInfo map[string]*string `json:"triggerInfo"`
	// URI - The URI of the build.
	URI *string `json:"uri,omitempty"`
	// URL - The REST URL of the build.
	URL               *string                    `json:"url,omitempty"`
	ValidationResults *[]RequestValidationResult `json:"validationResults,omitempty"`
}

// MarshalJSON is the custom marshaler for Model.
func (mVar Model) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mVar.Links != nil {
		objectMap["_links"] = mVar.Links
	}
	if mVar.BuildNumber != nil {
		objectMap["buildNumber"] = mVar.BuildNumber
	}
	if mVar.BuildNumberRevision != nil {
		objectMap["buildNumberRevision"] = mVar.BuildNumberRevision
	}
	if mVar.Controller != nil {
		objectMap["controller"] = mVar.Controller
	}
	if mVar.Definition != nil {
		objectMap["definition"] = mVar.Definition
	}
	if mVar.Deleted != nil {
		objectMap["deleted"] = mVar.Deleted
	}
	if mVar.DeletedBy != nil {
		objectMap["deletedBy"] = mVar.DeletedBy
	}
	if mVar.DeletedDate != nil {
		objectMap["deletedDate"] = mVar.DeletedDate
	}
	if mVar.DeletedReason != nil {
		objectMap["deletedReason"] = mVar.DeletedReason
	}
	if mVar.Demands != nil {
		objectMap["demands"] = mVar.Demands
	}
	if mVar.FinishTime != nil {
		objectMap["finishTime"] = mVar.FinishTime
	}
	if mVar.ID != nil {
		objectMap["id"] = mVar.ID
	}
	if mVar.KeepForever != nil {
		objectMap["keepForever"] = mVar.KeepForever
	}
	if mVar.LastChangedBy != nil {
		objectMap["lastChangedBy"] = mVar.LastChangedBy
	}
	if mVar.LastChangedDate != nil {
		objectMap["lastChangedDate"] = mVar.LastChangedDate
	}
	if mVar.Logs != nil {
		objectMap["logs"] = mVar.Logs
	}
	if mVar.OrchestrationPlan != nil {
		objectMap["orchestrationPlan"] = mVar.OrchestrationPlan
	}
	if mVar.Parameters != nil {
		objectMap["parameters"] = mVar.Parameters
	}
	if mVar.Plans != nil {
		objectMap["plans"] = mVar.Plans
	}
	if mVar.Priority != nil {
		objectMap["priority"] = mVar.Priority
	}
	if mVar.Project != nil {
		objectMap["project"] = mVar.Project
	}
	if mVar.Properties != nil {
		objectMap["properties"] = mVar.Properties
	}
	if mVar.Quality != nil {
		objectMap["quality"] = mVar.Quality
	}
	if mVar.Queue != nil {
		objectMap["queue"] = mVar.Queue
	}
	if mVar.QueueOptions != nil {
		objectMap["queueOptions"] = mVar.QueueOptions
	}
	if mVar.QueuePosition != nil {
		objectMap["queuePosition"] = mVar.QueuePosition
	}
	if mVar.QueueTime != nil {
		objectMap["queueTime"] = mVar.QueueTime
	}
	if mVar.Reason != nil {
		objectMap["reason"] = mVar.Reason
	}
	if mVar.Repository != nil {
		objectMap["repository"] = mVar.Repository
	}
	if mVar.RequestedBy != nil {
		objectMap["requestedBy"] = mVar.RequestedBy
	}
	if mVar.RequestedFor != nil {
		objectMap["requestedFor"] = mVar.RequestedFor
	}
	if mVar.Result != nil {
		objectMap["result"] = mVar.Result
	}
	if mVar.RetainedByRelease != nil {
		objectMap["retainedByRelease"] = mVar.RetainedByRelease
	}
	if mVar.SourceBranch != nil {
		objectMap["sourceBranch"] = mVar.SourceBranch
	}
	if mVar.SourceVersion != nil {
		objectMap["sourceVersion"] = mVar.SourceVersion
	}
	if mVar.StartTime != nil {
		objectMap["startTime"] = mVar.StartTime
	}
	if mVar.Status != nil {
		objectMap["status"] = mVar.Status
	}
	if mVar.Tags != nil {
		objectMap["tags"] = mVar.Tags
	}
	if mVar.TriggeredByBuild != nil {
		objectMap["triggeredByBuild"] = mVar.TriggeredByBuild
	}
	if mVar.TriggerInfo != nil {
		objectMap["triggerInfo"] = mVar.TriggerInfo
	}
	if mVar.URI != nil {
		objectMap["uri"] = mVar.URI
	}
	if mVar.URL != nil {
		objectMap["url"] = mVar.URL
	}
	if mVar.ValidationResults != nil {
		objectMap["validationResults"] = mVar.ValidationResults
	}
	return json.Marshal(objectMap)
}

// MultipleAgentExecutionOptions represents options for running a phase against multiple agents.
type MultipleAgentExecutionOptions struct {
	// ContinueOnError - Indicates whether failure on one agent should prevent the phase from running on other agents.
	ContinueOnError *bool `json:"continueOnError,omitempty"`
	// MaxConcurrency - The maximum number of agents to use simultaneously.
	MaxConcurrency *int32 `json:"maxConcurrency,omitempty"`
	// Type - Indicates the type of execution options.
	Type *int32 `json:"type,omitempty"`
}

// Option represents the application of an optional behavior to a build definition.
type Option struct {
	// Definition - A reference to the build option.
	Definition *OptionDefinitionReference `json:"definition,omitempty"`
	// Enabled - Indicates whether the behavior is enabled.
	Enabled *bool              `json:"enabled,omitempty"`
	Inputs  map[string]*string `json:"inputs"`
}

// MarshalJSON is the custom marshaler for Option.
func (o Option) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if o.Definition != nil {
		objectMap["definition"] = o.Definition
	}
	if o.Enabled != nil {
		objectMap["enabled"] = o.Enabled
	}
	if o.Inputs != nil {
		objectMap["inputs"] = o.Inputs
	}
	return json.Marshal(objectMap)
}

// OptionDefinition represents an optional behavior that can be applied to a build definition.
type OptionDefinition struct {
	// Description - The description.
	Description *string `json:"description,omitempty"`
	// Groups - The list of input groups defined for the build option.
	Groups *[]OptionGroupDefinition `json:"groups,omitempty"`
	// Inputs - The list of inputs defined for the build option.
	Inputs *[]OptionInputDefinition `json:"inputs,omitempty"`
	// Name - The name of the build option.
	Name *string `json:"name,omitempty"`
	// Ordinal - A value that indicates the relative order in which the behavior should be applied.
	Ordinal *int32 `json:"ordinal,omitempty"`
	// ID - The ID of the referenced build option.
	ID *uuid.UUID `json:"id,omitempty"`
}

// OptionDefinitionReference represents a reference to a build option definition.
type OptionDefinitionReference struct {
	// ID - The ID of the referenced build option.
	ID *uuid.UUID `json:"id,omitempty"`
}

// OptionGroupDefinition represents a group of inputs for a build option.
type OptionGroupDefinition struct {
	// DisplayName - The name of the group to display in the UI.
	DisplayName *string `json:"displayName,omitempty"`
	// IsExpanded - Indicates whether the group is initially displayed as expanded in the UI.
	IsExpanded *bool `json:"isExpanded,omitempty"`
	// Name - The internal name of the group.
	Name *string `json:"name,omitempty"`
}

// OptionInputDefinition represents an input for a build option.
type OptionInputDefinition struct {
	// DefaultValue - The default value.
	DefaultValue *string `json:"defaultValue,omitempty"`
	// GroupName - The name of the input group that this input belongs to.
	GroupName *string            `json:"groupName,omitempty"`
	Help      map[string]*string `json:"help"`
	// Label - The label for the input.
	Label *string `json:"label,omitempty"`
	// Name - The name of the input.
	Name    *string            `json:"name,omitempty"`
	Options map[string]*string `json:"options"`
	// Required - Indicates whether the input is required to have a value.
	Required *bool `json:"required,omitempty"`
	// Type - Indicates the type of the input value.
	Type interface{} `json:"type,omitempty"`
	// VisibleRule - The rule that is applied to determine whether the input is visible in the UI.
	VisibleRule *string `json:"visibleRule,omitempty"`
}

// MarshalJSON is the custom marshaler for OptionInputDefinition.
func (oid OptionInputDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if oid.DefaultValue != nil {
		objectMap["defaultValue"] = oid.DefaultValue
	}
	if oid.GroupName != nil {
		objectMap["groupName"] = oid.GroupName
	}
	if oid.Help != nil {
		objectMap["help"] = oid.Help
	}
	if oid.Label != nil {
		objectMap["label"] = oid.Label
	}
	if oid.Name != nil {
		objectMap["name"] = oid.Name
	}
	if oid.Options != nil {
		objectMap["options"] = oid.Options
	}
	if oid.Required != nil {
		objectMap["required"] = oid.Required
	}
	if oid.Type != nil {
		objectMap["type"] = oid.Type
	}
	if oid.VisibleRule != nil {
		objectMap["visibleRule"] = oid.VisibleRule
	}
	return json.Marshal(objectMap)
}

// Phase represents a phase of a build definition.
type Phase struct {
	// Condition - The condition that must be true for this phase to execute.
	Condition    *string       `json:"condition,omitempty"`
	Dependencies *[]Dependency `json:"dependencies,omitempty"`
	// JobAuthorizationScope - The job authorization scope for builds queued against this definition.
	JobAuthorizationScope interface{} `json:"jobAuthorizationScope,omitempty"`
	// JobCancelTimeoutInMinutes - The cancellation timeout, in minutes, for builds queued against this definition.
	JobCancelTimeoutInMinutes *int32 `json:"jobCancelTimeoutInMinutes,omitempty"`
	// JobTimeoutInMinutes - The job execution timeout, in minutes, for builds queued against this definition.
	JobTimeoutInMinutes *int32 `json:"jobTimeoutInMinutes,omitempty"`
	// Name - The name of the phase.
	Name *string `json:"name,omitempty"`
	// RefName - The unique ref name of the phase.
	RefName *string           `json:"refName,omitempty"`
	Steps   *[]DefinitionStep `json:"steps,omitempty"`
	// Target - The target (agent, server, etc.) for this phase.
	Target    *PhaseTarget                   `json:"target,omitempty"`
	Variables map[string]*DefinitionVariable `json:"variables"`
}

// MarshalJSON is the custom marshaler for Phase.
func (p Phase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.Condition != nil {
		objectMap["condition"] = p.Condition
	}
	if p.Dependencies != nil {
		objectMap["dependencies"] = p.Dependencies
	}
	if p.JobAuthorizationScope != nil {
		objectMap["jobAuthorizationScope"] = p.JobAuthorizationScope
	}
	if p.JobCancelTimeoutInMinutes != nil {
		objectMap["jobCancelTimeoutInMinutes"] = p.JobCancelTimeoutInMinutes
	}
	if p.JobTimeoutInMinutes != nil {
		objectMap["jobTimeoutInMinutes"] = p.JobTimeoutInMinutes
	}
	if p.Name != nil {
		objectMap["name"] = p.Name
	}
	if p.RefName != nil {
		objectMap["refName"] = p.RefName
	}
	if p.Steps != nil {
		objectMap["steps"] = p.Steps
	}
	if p.Target != nil {
		objectMap["target"] = p.Target
	}
	if p.Variables != nil {
		objectMap["variables"] = p.Variables
	}
	return json.Marshal(objectMap)
}

// PhaseTarget represents the target of a phase.
type PhaseTarget struct {
	// Type - The type of the target.
	Type *int32 `json:"type,omitempty"`
}

// Process represents a build process.
//type Process struct {
	// Type - The type of the process.
//	Type *int32 `json:"type,omitempty"`
//}

// ProcessParameters ...
type ProcessParameters struct {
	DataSourceBindings *[]DataSourceBindingBase    `json:"dataSourceBindings,omitempty"`
	Inputs             *[]TaskInputDefinitionBase  `json:"inputs,omitempty"`
	SourceDefinitions  *[]TaskSourceDefinitionBase `json:"sourceDefinitions,omitempty"`
}

// ProcessResources represents resources used by a build process.
type ProcessResources struct {
	Endpoints      *[]ServiceEndpointReference `json:"endpoints,omitempty"`
	Files          *[]SecureFileReference      `json:"files,omitempty"`
	Queues         *[]AgentPoolQueueReference  `json:"queues,omitempty"`
	VariableGroups *[]VariableGroupReference   `json:"variableGroups,omitempty"`
}

// ProcessTemplate ...
type ProcessTemplate struct {
	Description      *string     `json:"description,omitempty"`
	FileExists       *bool       `json:"fileExists,omitempty"`
	ID               *int32      `json:"id,omitempty"`
	Parameters       *string     `json:"parameters,omitempty"`
	ServerPath       *string     `json:"serverPath,omitempty"`
	SupportedReasons interface{} `json:"supportedReasons,omitempty"`
	TeamProject      *string     `json:"teamProject,omitempty"`
	TemplateType     interface{} `json:"templateType,omitempty"`
	URL              *string     `json:"url,omitempty"`
	Version          *string     `json:"version,omitempty"`
}

// PropertiesCollection the class represents a property bag as a collection of key-value pairs. Values of
// all primitive types (any type with a `TypeCode != TypeCode.Object`) except for `DBNull` are accepted.
// Values of type Byte[], Int32, Double, DateType and String preserve their type, other primitives are
// retuned as a String. Byte[] expected as base64 encoded string.
type PropertiesCollection struct {
	autorest.Response `json:"-"`
	// Count - The count of properties in the collection.
	Count *int32      `json:"count,omitempty"`
	Item  interface{} `json:"item,omitempty"`
	// Keys - The set of keys in the collection.
	Keys *[]string `json:"keys,omitempty"`
	// Values - The set of values in the collection.
	Values *[]string `json:"values,omitempty"`
}

// PullRequest represents a pull request object.  These are retrieved from Source Providers.
type PullRequest struct {
	autorest.Response `json:"-"`
	// Links - The links to other objects related to this object.
	Links *ReferenceLinks `json:"_links,omitempty"`
	// Author - Author of the pull request.
	Author *IdentityRef `json:"author,omitempty"`
	// CurrentState - Current state of the pull request, e.g. open, merged, closed, conflicts, etc.
	CurrentState *string `json:"currentState,omitempty"`
	// Description - Description for the pull request.
	Description *string `json:"description,omitempty"`
	// ID - Unique identifier for the pull request
	ID *string `json:"id,omitempty"`
	// ProviderName - The name of the provider this pull request is associated with.
	ProviderName *string `json:"providerName,omitempty"`
	// SourceBranchRef - Source branch ref of this pull request
	SourceBranchRef *string `json:"sourceBranchRef,omitempty"`
	// SourceRepositoryOwner - Owner of the source repository of this pull request
	SourceRepositoryOwner *string `json:"sourceRepositoryOwner,omitempty"`
	// TargetBranchRef - Target branch ref of this pull request
	TargetBranchRef *string `json:"targetBranchRef,omitempty"`
	// TargetRepositoryOwner - Owner of the target repository of this pull request
	TargetRepositoryOwner *string `json:"targetRepositoryOwner,omitempty"`
	// Title - Title of the pull request.
	Title *string `json:"title,omitempty"`
}

// PullRequestTrigger represents a pull request trigger.
type PullRequestTrigger struct {
	// AutoCancel - Indicates if an update to a PR should delete current in-progress builds.
	AutoCancel                      *bool     `json:"autoCancel,omitempty"`
	BranchFilters                   *[]string `json:"branchFilters,omitempty"`
	Forks                           *Forks    `json:"forks,omitempty"`
	IsCommentRequiredForPullRequest *bool     `json:"isCommentRequiredForPullRequest,omitempty"`
	PathFilters                     *[]string `json:"pathFilters,omitempty"`
	SettingsSourceType              *int32    `json:"settingsSourceType,omitempty"`
	// TriggerType - The type of the trigger.
	TriggerType interface{} `json:"triggerType,omitempty"`
}

// RealtimeBuildEvent ...
type RealtimeBuildEvent struct {
	BuildID *int32 `json:"buildId,omitempty"`
}

// Reference represents a reference to a build.
type Reference struct {
	Links *ReferenceLinks `json:"_links,omitempty"`
	// BuildNumber - The build number.
	BuildNumber *string `json:"buildNumber,omitempty"`
	// Deleted - Indicates whether the build has been deleted.
	Deleted *bool `json:"deleted,omitempty"`
	// FinishTime - The time that the build was completed.
	FinishTime *date.Time `json:"finishTime,omitempty"`
	// ID - The ID of the build.
	ID *int32 `json:"id,omitempty"`
	// QueueTime - The time that the build was queued.
	QueueTime *date.Time `json:"queueTime,omitempty"`
	// RequestedFor - The identity on whose behalf the build was queued.
	RequestedFor *IdentityRef `json:"requestedFor,omitempty"`
	// Result - The build result.
	Result interface{} `json:"result,omitempty"`
	// StartTime - The time that the build was started.
	StartTime *date.Time `json:"startTime,omitempty"`
	// Status - The build status.
	Status interface{} `json:"status,omitempty"`
}

// ReferenceLinks the class to represent a collection of REST reference links.
type ReferenceLinks struct {
	// Links - The readonly view of the links.  Because Reference links are readonly, we only want to expose them as read only.
	Links map[string]interface{} `json:"links"`
}

// MarshalJSON is the custom marshaler for ReferenceLinks.
func (rl ReferenceLinks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rl.Links != nil {
		objectMap["links"] = rl.Links
	}
	return json.Marshal(objectMap)
}

// ReleaseReference reference to a release.
type ReleaseReference struct {
	Attempt      *int32     `json:"attempt,omitempty"`
	CreationDate *date.Time `json:"creationDate,omitempty"`
	// DefinitionID - Release definition ID.
	DefinitionID            *int32     `json:"definitionId,omitempty"`
	EnvironmentCreationDate *date.Time `json:"environmentCreationDate,omitempty"`
	// EnvironmentDefinitionID - Release environment definition ID.
	EnvironmentDefinitionID *int32 `json:"environmentDefinitionId,omitempty"`
	// EnvironmentDefinitionName - Release environment definition name.
	EnvironmentDefinitionName *string `json:"environmentDefinitionName,omitempty"`
	// EnvironmentID - Release environment ID.
	EnvironmentID *int32 `json:"environmentId,omitempty"`
	// EnvironmentName - Release environment name.
	EnvironmentName *string `json:"environmentName,omitempty"`
	// ID - Release ID.
	ID *int32 `json:"id,omitempty"`
	// Name - Release name.
	Name *string `json:"name,omitempty"`
}

// ReportMetadata represents information about a build report.
type ReportMetadata struct {
	autorest.Response `json:"-"`
	// BuildID - The Id of the build.
	BuildID *int32 `json:"buildId,omitempty"`
	// Content - The content of the report.
	Content *string `json:"content,omitempty"`
	// Type - The type of the report.
	Type *string `json:"type,omitempty"`
}

// Repository represents a repository used by a build definition.
type Repository struct {
	// CheckoutSubmodules - Indicates whether to checkout submodules.
	CheckoutSubmodules *bool `json:"checkoutSubmodules,omitempty"`
	// Clean - Indicates whether to clean the target folder when getting code from the repository.
	Clean *string `json:"clean,omitempty"`
	// DefaultBranch - The name of the default branch.
	DefaultBranch *string `json:"defaultBranch,omitempty"`
	// ID - The ID of the repository.
	ID *string `json:"id,omitempty"`
	// Name - The friendly name of the repository.
	Name       *string            `json:"name,omitempty"`
	Properties map[string]*string `json:"properties"`
	// RootFolder - The root folder.
	RootFolder *string `json:"rootFolder,omitempty"`
	// Type - The type of the repository.
	Type *string `json:"type,omitempty"`
	// URL - The URL of the repository.
	URL *string `json:"url,omitempty"`
}

// MarshalJSON is the custom marshaler for Repository.
func (r Repository) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.CheckoutSubmodules != nil {
		objectMap["checkoutSubmodules"] = r.CheckoutSubmodules
	}
	if r.Clean != nil {
		objectMap["clean"] = r.Clean
	}
	if r.DefaultBranch != nil {
		objectMap["defaultBranch"] = r.DefaultBranch
	}
	if r.ID != nil {
		objectMap["id"] = r.ID
	}
	if r.Name != nil {
		objectMap["name"] = r.Name
	}
	if r.Properties != nil {
		objectMap["properties"] = r.Properties
	}
	if r.RootFolder != nil {
		objectMap["rootFolder"] = r.RootFolder
	}
	if r.Type != nil {
		objectMap["type"] = r.Type
	}
	if r.URL != nil {
		objectMap["url"] = r.URL
	}
	return json.Marshal(objectMap)
}

// RepositoryWebhook represents a repository's webhook returned from a source provider.
type RepositoryWebhook struct {
	// Name - The friendly name of the repository.
	Name  *string        `json:"name,omitempty"`
	Types *[]interface{} `json:"types,omitempty"`
	// URL - The URL of the repository.
	URL *string `json:"url,omitempty"`
}

// RequestValidationResult represents the result of validating a build request.
type RequestValidationResult struct {
	// Message - The message associated with the result.
	Message *string `json:"message,omitempty"`
	// Result - The result.
	Result interface{} `json:"result,omitempty"`
}

// ResourceRef ...
type ResourceRef struct {
	ID  *string `json:"id,omitempty"`
	URL *string `json:"url,omitempty"`
}

// ResourceReference represents a reference to a resource.
type ResourceReference struct {
	// Alias - An alias to be used when referencing the resource.
	Alias *string `json:"alias,omitempty"`
}

// ResourceUsage represents information about resources used by builds in the system.
type ResourceUsage struct {
	autorest.Response `json:"-"`
	// DistributedTaskAgents - The number of build agents.
	DistributedTaskAgents *int32 `json:"distributedTaskAgents,omitempty"`
	// PaidPrivateAgentSlots - The number of paid private agent slots.
	PaidPrivateAgentSlots *int32 `json:"paidPrivateAgentSlots,omitempty"`
	// TotalUsage - The total usage.
	TotalUsage *int32 `json:"totalUsage,omitempty"`
	// XamlControllers - The number of XAML controllers.
	XamlControllers *int32 `json:"xamlControllers,omitempty"`
}

// RetentionPolicy represents a retention policy for a build definition.
type RetentionPolicy struct {
	Artifacts             *[]string `json:"artifacts,omitempty"`
	ArtifactTypesToDelete *[]string `json:"artifactTypesToDelete,omitempty"`
	Branches              *[]string `json:"branches,omitempty"`
	// DaysToKeep - The number of days to keep builds.
	DaysToKeep *int32 `json:"daysToKeep,omitempty"`
	// DeleteBuildRecord - Indicates whether the build record itself should be deleted.
	DeleteBuildRecord *bool `json:"deleteBuildRecord,omitempty"`
	// DeleteTestResults - Indicates whether to delete test results associated with the build.
	DeleteTestResults *bool `json:"deleteTestResults,omitempty"`
	// MinimumToKeep - The minimum number of builds to keep.
	MinimumToKeep *int32 `json:"minimumToKeep,omitempty"`
}

// Schedule ...
type Schedule struct {
	BranchFilters *[]string `json:"branchFilters,omitempty"`
	// DaysToBuild - Days for a build (flags enum for days of the week)
	DaysToBuild interface{} `json:"daysToBuild,omitempty"`
	// ScheduleJobID - The Job Id of the Scheduled job that will queue the scheduled build. Since a single trigger can have multiple schedules and we want a single job to process a single schedule (since each schedule has a list of branches to build), the schedule itself needs to define the Job Id. This value will be filled in when a definition is added or updated.  The UI does not provide it or use it.
	ScheduleJobID *uuid.UUID `json:"scheduleJobId,omitempty"`
	// ScheduleOnlyWithChanges - Flag to determine if this schedule should only build if the associated source has been changed.
	ScheduleOnlyWithChanges *bool `json:"scheduleOnlyWithChanges,omitempty"`
	// StartHours - Local timezone hour to start
	StartHours *int32 `json:"startHours,omitempty"`
	// StartMinutes - Local timezone minute to start
	StartMinutes *int32 `json:"startMinutes,omitempty"`
	// TimeZoneID - Time zone of the build schedule (String representation of the time zone ID)
	TimeZoneID *string `json:"timeZoneId,omitempty"`
}

// ScheduleTrigger represents a schedule trigger.
type ScheduleTrigger struct {
	Schedules *[]Schedule `json:"schedules,omitempty"`
	// TriggerType - The type of the trigger.
	TriggerType interface{} `json:"triggerType,omitempty"`
}

// SecureFileReference represents a reference to a secure file.
type SecureFileReference struct {
	// ID - The ID of the secure file.
	ID *uuid.UUID `json:"id,omitempty"`
	// Alias - An alias to be used when referencing the resource.
	Alias *string `json:"alias,omitempty"`
}

// Server ...
type Server struct {
	Agents                    *[]AgentReference             `json:"agents,omitempty"`
	Controller                *XamlBuildControllerReference `json:"controller,omitempty"`
	ID                        *int32                        `json:"id,omitempty"`
	IsVirtual                 *bool                         `json:"isVirtual,omitempty"`
	MessageQueueURL           *string                       `json:"messageQueueUrl,omitempty"`
	Name                      *string                       `json:"name,omitempty"`
	RequireClientCertificates *bool                         `json:"requireClientCertificates,omitempty"`
	Status                    interface{}                   `json:"status,omitempty"`
	StatusChangedDate         *date.Time                    `json:"statusChangedDate,omitempty"`
	URI                       *string                       `json:"uri,omitempty"`
	URL                       *string                       `json:"url,omitempty"`
	Version                   *int32                        `json:"version,omitempty"`
}

// ServerTarget represents a phase target that runs on the server.
type ServerTarget struct {
	// ExecutionOptions - The execution options.
	ExecutionOptions *ServerTargetExecutionOptions `json:"executionOptions,omitempty"`
	// Type - The type of the target.
	Type *int32 `json:"type,omitempty"`
}

// ServerTargetExecutionOptions represents options for running a phase on the server.
type ServerTargetExecutionOptions struct {
	// Type - The type.
	Type *int32 `json:"type,omitempty"`
}

// ServiceEndpointReference represents a referenec to a service endpoint.
type ServiceEndpointReference struct {
	// ID - The ID of the service endpoint.
	ID *uuid.UUID `json:"id,omitempty"`
	// Alias - An alias to be used when referencing the resource.
	Alias *string `json:"alias,omitempty"`
}

// Settings represents system-wide build settings.
type Settings struct {
	autorest.Response `json:"-"`
	// DaysToKeepDeletedBuildsBeforeDestroy - The number of days to keep records of deleted builds.
	DaysToKeepDeletedBuildsBeforeDestroy *int32 `json:"daysToKeepDeletedBuildsBeforeDestroy,omitempty"`
	// DefaultRetentionPolicy - The default retention policy.
	DefaultRetentionPolicy *RetentionPolicy `json:"defaultRetentionPolicy,omitempty"`
	// MaximumRetentionPolicy - The maximum retention policy.
	MaximumRetentionPolicy *RetentionPolicy `json:"maximumRetentionPolicy,omitempty"`
}

// SourceProviderAttributes ...
type SourceProviderAttributes struct {
	// Name - The name of the source provider.
	Name *string `json:"name,omitempty"`
	// SupportedCapabilities - The capabilities supported by this source provider.
	SupportedCapabilities map[string]*bool `json:"supportedCapabilities"`
	// SupportedTriggers - The types of triggers supported by this source provider.
	SupportedTriggers *[]SupportedTrigger `json:"supportedTriggers,omitempty"`
}

// MarshalJSON is the custom marshaler for SourceProviderAttributes.
func (spa SourceProviderAttributes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if spa.Name != nil {
		objectMap["name"] = spa.Name
	}
	if spa.SupportedCapabilities != nil {
		objectMap["supportedCapabilities"] = spa.SupportedCapabilities
	}
	if spa.SupportedTriggers != nil {
		objectMap["supportedTriggers"] = spa.SupportedTriggers
	}
	return json.Marshal(objectMap)
}

// SourceRelatedWorkItem represents a work item related to some source item. These are retrieved from
// Source Providers.
type SourceRelatedWorkItem struct {
	Links *ReferenceLinks `json:"_links,omitempty"`
	// AssignedTo - Identity ref for the person that the work item is assigned to.
	AssignedTo *IdentityRef `json:"assignedTo,omitempty"`
	// CurrentState - Current state of the work item, e.g. Active, Resolved, Closed, etc.
	CurrentState *string `json:"currentState,omitempty"`
	// Description - Long description for the work item.
	Description *string `json:"description,omitempty"`
	// ID - Unique identifier for the work item
	ID *string `json:"id,omitempty"`
	// ProviderName - The name of the provider the work item is associated with.
	ProviderName *string `json:"providerName,omitempty"`
	// Title - Short name for the work item.
	Title *string `json:"title,omitempty"`
	// Type - Type of work item, e.g. Bug, Task, User Story, etc.
	Type *string `json:"type,omitempty"`
}

// SourceRepositories a set of repositories returned from the source provider.
type SourceRepositories struct {
	autorest.Response `json:"-"`
	// ContinuationToken - A token used to continue this paged request; 'null' if the request is complete
	ContinuationToken *string `json:"continuationToken,omitempty"`
	// PageLength - The number of repositories requested for each page
	PageLength *int32 `json:"pageLength,omitempty"`
	// Repositories - A list of repositories
	Repositories *[]SourceRepository `json:"repositories,omitempty"`
	// TotalPageCount - The total number of pages, or '-1' if unknown
	TotalPageCount *int32 `json:"totalPageCount,omitempty"`
}

// SourceRepository represents a repository returned from a source provider.
type SourceRepository struct {
	// DefaultBranch - The name of the default branch.
	DefaultBranch *string `json:"defaultBranch,omitempty"`
	// FullName - The full name of the repository.
	FullName *string `json:"fullName,omitempty"`
	// ID - The ID of the repository.
	ID *string `json:"id,omitempty"`
	// Name - The friendly name of the repository.
	Name       *string            `json:"name,omitempty"`
	Properties map[string]*string `json:"properties"`
	// SourceProviderName - The name of the source provider the repository is from.
	SourceProviderName *string `json:"sourceProviderName,omitempty"`
	// URL - The URL of the repository.
	URL *string `json:"url,omitempty"`
}

// MarshalJSON is the custom marshaler for SourceRepository.
func (sr SourceRepository) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sr.DefaultBranch != nil {
		objectMap["defaultBranch"] = sr.DefaultBranch
	}
	if sr.FullName != nil {
		objectMap["fullName"] = sr.FullName
	}
	if sr.ID != nil {
		objectMap["id"] = sr.ID
	}
	if sr.Name != nil {
		objectMap["name"] = sr.Name
	}
	if sr.Properties != nil {
		objectMap["properties"] = sr.Properties
	}
	if sr.SourceProviderName != nil {
		objectMap["sourceProviderName"] = sr.SourceProviderName
	}
	if sr.URL != nil {
		objectMap["url"] = sr.URL
	}
	return json.Marshal(objectMap)
}

// SourceRepositoryItem represents an item in a repository from a source provider.
type SourceRepositoryItem struct {
	// IsContainer - Whether the item is able to have sub-items (e.g., is a folder).
	IsContainer *bool `json:"isContainer,omitempty"`
	// Path - The full path of the item, relative to the root of the repository.
	Path *string `json:"path,omitempty"`
	// Type - The type of the item (folder, file, etc).
	Type *string `json:"type,omitempty"`
	// URL - The URL of the item.
	URL *string `json:"url,omitempty"`
}

// String ...
type String struct {
	autorest.Response `json:"-"`
	Value             *string `json:"value,omitempty"`
}

// Summary ...
type Summary struct {
	BuildProperty *XamlBuildReference `json:"build,omitempty"`
	FinishTime    *date.Time          `json:"finishTime,omitempty"`
	KeepForever   *bool               `json:"keepForever,omitempty"`
	Quality       *string             `json:"quality,omitempty"`
	Reason        interface{}         `json:"reason,omitempty"`
	RequestedFor  *IdentityRef        `json:"requestedFor,omitempty"`
	StartTime     *date.Time          `json:"startTime,omitempty"`
	Status        interface{}         `json:"status,omitempty"`
}

// SupportedTrigger ...
type SupportedTrigger struct {
	// DefaultPollingInterval - The default interval to wait between polls (only relevant when NotificationType is Polling).
	DefaultPollingInterval *int32 `json:"defaultPollingInterval,omitempty"`
	// NotificationType - How the trigger is notified of changes.
	NotificationType *string `json:"notificationType,omitempty"`
	// SupportedCapabilities - The capabilities supported by this trigger.
	SupportedCapabilities map[string]interface{} `json:"supportedCapabilities"`
	// Type - The type of trigger.
	Type interface{} `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SupportedTrigger.
func (st SupportedTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if st.DefaultPollingInterval != nil {
		objectMap["defaultPollingInterval"] = st.DefaultPollingInterval
	}
	if st.NotificationType != nil {
		objectMap["notificationType"] = st.NotificationType
	}
	if st.SupportedCapabilities != nil {
		objectMap["supportedCapabilities"] = st.SupportedCapabilities
	}
	if st.Type != nil {
		objectMap["type"] = st.Type
	}
	return json.Marshal(objectMap)
}

// SvnMappingDetails represents a Subversion mapping entry.
type SvnMappingDetails struct {
	// Depth - The depth.
	Depth *int32 `json:"depth,omitempty"`
	// IgnoreExternals - Indicates whether to ignore externals.
	IgnoreExternals *bool `json:"ignoreExternals,omitempty"`
	// LocalPath - The local path.
	LocalPath *string `json:"localPath,omitempty"`
	// Revision - The revision.
	Revision *string `json:"revision,omitempty"`
	// ServerPath - The server path.
	ServerPath *string `json:"serverPath,omitempty"`
}

// SvnWorkspace represents a subversion workspace.
type SvnWorkspace struct {
	Mappings *[]SvnMappingDetails `json:"mappings,omitempty"`
}

// TagsAddedEvent ...
type TagsAddedEvent struct {
	AllTags       *[]string `json:"allTags,omitempty"`
	NewTags       *[]string `json:"newTags,omitempty"`
	BuildProperty *Model    `json:"build,omitempty"`
	BuildID       *int32    `json:"buildId,omitempty"`
}

// TaskAgentPoolReference represents a reference to an agent pool.
type TaskAgentPoolReference struct {
	// ID - The pool ID.
	ID *int32 `json:"id,omitempty"`
	// IsHosted - A value indicating whether or not this pool is managed by the service.
	IsHosted *bool `json:"isHosted,omitempty"`
	// Name - The pool name.
	Name *string `json:"name,omitempty"`
}

// TaskDefinitionReference a reference to a task definition.
type TaskDefinitionReference struct {
	// DefinitionType - The type of task (task or task group).
	DefinitionType *string `json:"definitionType,omitempty"`
	// ID - The ID of the task.
	ID *uuid.UUID `json:"id,omitempty"`
	// VersionSpec - The version of the task.
	VersionSpec *string `json:"versionSpec,omitempty"`
}

// TaskInputDefinitionBase ...
type TaskInputDefinitionBase struct {
	Aliases      *[]string            `json:"aliases,omitempty"`
	DefaultValue *string              `json:"defaultValue,omitempty"`
	GroupName    *string              `json:"groupName,omitempty"`
	HelpMarkDown *string              `json:"helpMarkDown,omitempty"`
	Label        *string              `json:"label,omitempty"`
	Name         *string              `json:"name,omitempty"`
	Options      map[string]*string   `json:"options"`
	Properties   map[string]*string   `json:"properties"`
	Required     *bool                `json:"required,omitempty"`
	Type         *string              `json:"type,omitempty"`
	Validation   *TaskInputValidation `json:"validation,omitempty"`
	VisibleRule  *string              `json:"visibleRule,omitempty"`
}

// MarshalJSON is the custom marshaler for TaskInputDefinitionBase.
func (tidb TaskInputDefinitionBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tidb.Aliases != nil {
		objectMap["aliases"] = tidb.Aliases
	}
	if tidb.DefaultValue != nil {
		objectMap["defaultValue"] = tidb.DefaultValue
	}
	if tidb.GroupName != nil {
		objectMap["groupName"] = tidb.GroupName
	}
	if tidb.HelpMarkDown != nil {
		objectMap["helpMarkDown"] = tidb.HelpMarkDown
	}
	if tidb.Label != nil {
		objectMap["label"] = tidb.Label
	}
	if tidb.Name != nil {
		objectMap["name"] = tidb.Name
	}
	if tidb.Options != nil {
		objectMap["options"] = tidb.Options
	}
	if tidb.Properties != nil {
		objectMap["properties"] = tidb.Properties
	}
	if tidb.Required != nil {
		objectMap["required"] = tidb.Required
	}
	if tidb.Type != nil {
		objectMap["type"] = tidb.Type
	}
	if tidb.Validation != nil {
		objectMap["validation"] = tidb.Validation
	}
	if tidb.VisibleRule != nil {
		objectMap["visibleRule"] = tidb.VisibleRule
	}
	return json.Marshal(objectMap)
}

// TaskInputValidation ...
type TaskInputValidation struct {
	// Expression - Conditional expression
	Expression *string `json:"expression,omitempty"`
	// Message - Message explaining how user can correct if validation fails
	Message *string `json:"message,omitempty"`
}

// TaskOrchestrationPlanGroupReference represents a reference to a plan group.
type TaskOrchestrationPlanGroupReference struct {
	// PlanGroup - The name of the plan group.
	PlanGroup *string `json:"planGroup,omitempty"`
	// ProjectID - The project ID.
	ProjectID *uuid.UUID `json:"projectId,omitempty"`
}

// TaskOrchestrationPlanGroupsStartedEvent ...
type TaskOrchestrationPlanGroupsStartedEvent struct {
	PlanGroups *[]TaskOrchestrationPlanGroupReference `json:"planGroups,omitempty"`
}

// TaskOrchestrationPlanReference represents a reference to an orchestration plan.
type TaskOrchestrationPlanReference struct {
	// OrchestrationType - The type of the plan.
	OrchestrationType *int32 `json:"orchestrationType,omitempty"`
	// PlanID - The ID of the plan.
	PlanID *uuid.UUID `json:"planId,omitempty"`
}

// TaskReference represents a reference to a task.
type TaskReference struct {
	// ID - The ID of the task definition.
	ID *uuid.UUID `json:"id,omitempty"`
	// Name - The name of the task definition.
	Name *string `json:"name,omitempty"`
	// Version - The version of the task definition.
	Version *string `json:"version,omitempty"`
}

// TaskSourceDefinitionBase ...
type TaskSourceDefinitionBase struct {
	AuthKey     *string `json:"authKey,omitempty"`
	Endpoint    *string `json:"endpoint,omitempty"`
	KeySelector *string `json:"keySelector,omitempty"`
	Selector    *string `json:"selector,omitempty"`
	Target      *string `json:"target,omitempty"`
}

// TeamProjectReference represents a shallow reference to a TeamProject.
type TeamProjectReference struct {
	// Abbreviation - Project abbreviation.
	Abbreviation *string `json:"abbreviation,omitempty"`
	// DefaultTeamImageURL - Url to default team identity image.
	DefaultTeamImageURL *string `json:"defaultTeamImageUrl,omitempty"`
	// Description - The project's description (if any).
	Description *string `json:"description,omitempty"`
	// ID - Project identifier.
	ID *uuid.UUID `json:"id,omitempty"`
	// LastUpdateTime - Project last update time.
	LastUpdateTime *date.Time `json:"lastUpdateTime,omitempty"`
	// Name - Project name.
	Name *string `json:"name,omitempty"`
	// Revision - Project revision.
	Revision *int64 `json:"revision,omitempty"`
	// State - Project state.
	State interface{} `json:"state,omitempty"`
	// URL - Url to the full version of the object.
	URL *string `json:"url,omitempty"`
	// Visibility - Project visibility.
	Visibility interface{} `json:"visibility,omitempty"`
}

// TestResultsContext ...
type TestResultsContext struct {
	BuildProperty *Reference        `json:"build,omitempty"`
	ContextType   interface{}       `json:"contextType,omitempty"`
	Release       *ReleaseReference `json:"release,omitempty"`
}

// Timeline represents the timeline of a build.
type Timeline struct {
	autorest.Response `json:"-"`
	// LastChangedBy - The process or person that last changed the timeline.
	LastChangedBy *uuid.UUID `json:"lastChangedBy,omitempty"`
	// LastChangedOn - The time the timeline was last changed.
	LastChangedOn *date.Time        `json:"lastChangedOn,omitempty"`
	Records       *[]TimelineRecord `json:"records,omitempty"`
	// ChangeID - The change ID.
	ChangeID *int32 `json:"changeId,omitempty"`
	// ID - The ID of the timeline.
	ID *uuid.UUID `json:"id,omitempty"`
	// URL - The REST URL of the timeline.
	URL *string `json:"url,omitempty"`
}

// TimelineAttempt ...
type TimelineAttempt struct {
	// Attempt - Gets or sets the attempt of the record.
	Attempt *int32 `json:"attempt,omitempty"`
	// RecordID - Gets or sets the record identifier located within the specified timeline.
	RecordID *uuid.UUID `json:"recordId,omitempty"`
	// TimelineID - Gets or sets the timeline identifier which owns the record representing this attempt.
	TimelineID *uuid.UUID `json:"timelineId,omitempty"`
}

// TimelineRecord represents an entry in a build's timeline.
type TimelineRecord struct {
	Links *ReferenceLinks `json:"_links,omitempty"`
	// Attempt - Attempt number of record.
	Attempt *int32 `json:"attempt,omitempty"`
	// ChangeID - The change ID.
	ChangeID *int32 `json:"changeId,omitempty"`
	// CurrentOperation - A string that indicates the current operation.
	CurrentOperation *string `json:"currentOperation,omitempty"`
	// Details - A reference to a sub-timeline.
	Details *TimelineReference `json:"details,omitempty"`
	// ErrorCount - The number of errors produced by this operation.
	ErrorCount *int32 `json:"errorCount,omitempty"`
	// FinishTime - The finish time.
	FinishTime *date.Time `json:"finishTime,omitempty"`
	// ID - The ID of the record.
	ID *uuid.UUID `json:"id,omitempty"`
	// Identifier - String identifier that is consistent across attempts.
	Identifier *string  `json:"identifier,omitempty"`
	Issues     *[]Issue `json:"issues,omitempty"`
	// LastModified - The time the record was last modified.
	LastModified *date.Time `json:"lastModified,omitempty"`
	// Log - A reference to the log produced by this operation.
	Log *LogReference `json:"log,omitempty"`
	// Name - The name.
	Name *string `json:"name,omitempty"`
	// Order - An ordinal value relative to other records.
	Order *int32 `json:"order,omitempty"`
	// ParentID - The ID of the record's parent.
	ParentID *uuid.UUID `json:"parentId,omitempty"`
	// PercentComplete - The current completion percentage.
	PercentComplete  *int32             `json:"percentComplete,omitempty"`
	PreviousAttempts *[]TimelineAttempt `json:"previousAttempts,omitempty"`
	// Result - The result.
	Result interface{} `json:"result,omitempty"`
	// ResultCode - The result code.
	ResultCode *string `json:"resultCode,omitempty"`
	// StartTime - The start time.
	StartTime *date.Time `json:"startTime,omitempty"`
	// State - The state of the record.
	State interface{} `json:"state,omitempty"`
	// Task - A reference to the task represented by this timeline record.
	Task *TaskReference `json:"task,omitempty"`
	// Type - The type of the record.
	Type *string `json:"type,omitempty"`
	// URL - The REST URL of the timeline record.
	URL *string `json:"url,omitempty"`
	// WarningCount - The number of warnings produced by this operation.
	WarningCount *int32 `json:"warningCount,omitempty"`
	// WorkerName - The name of the agent running the operation.
	WorkerName *string `json:"workerName,omitempty"`
}

// TimelineRecordsUpdatedEvent ...
type TimelineRecordsUpdatedEvent struct {
	TimelineRecords *[]TimelineRecord `json:"timelineRecords,omitempty"`
	BuildID         *int32            `json:"buildId,omitempty"`
}

// TimelineReference represents a reference to a timeline.
type TimelineReference struct {
	// ChangeID - The change ID.
	ChangeID *int32 `json:"changeId,omitempty"`
	// ID - The ID of the timeline.
	ID *uuid.UUID `json:"id,omitempty"`
	// URL - The REST URL of the timeline.
	URL *string `json:"url,omitempty"`
}

// Trigger represents a trigger for a buld definition.
type Trigger struct {
	// TriggerType - The type of the trigger.
	TriggerType interface{} `json:"triggerType,omitempty"`
}

// UpdatedEvent ...
type UpdatedEvent struct {
	BuildProperty *Model `json:"build,omitempty"`
	BuildID       *int32 `json:"buildId,omitempty"`
}

// VariableGroup represents a variable group.
type VariableGroup struct {
	// Description - The description.
	Description *string `json:"description,omitempty"`
	// Name - The name of the variable group.
	Name *string `json:"name,omitempty"`
	// Type - The type of the variable group.
	Type      *string                        `json:"type,omitempty"`
	Variables map[string]*DefinitionVariable `json:"variables"`
	// Alias - The Name of the variable group.
	Alias *string `json:"alias,omitempty"`
	// ID - The ID of the variable group.
	ID *int32 `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for VariableGroup.
func (vg VariableGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vg.Description != nil {
		objectMap["description"] = vg.Description
	}
	if vg.Name != nil {
		objectMap["name"] = vg.Name
	}
	if vg.Type != nil {
		objectMap["type"] = vg.Type
	}
	if vg.Variables != nil {
		objectMap["variables"] = vg.Variables
	}
	if vg.Alias != nil {
		objectMap["alias"] = vg.Alias
	}
	if vg.ID != nil {
		objectMap["id"] = vg.ID
	}
	return json.Marshal(objectMap)
}

// VariableGroupReference represents a reference to a variable group.
type VariableGroupReference struct {
	// Alias - The Name of the variable group.
	Alias *string `json:"alias,omitempty"`
	// ID - The ID of the variable group.
	ID *int32 `json:"id,omitempty"`
}

// VariableMultipliersAgentExecutionOptions represents options for running a phase based on values
// specified by a list of variables.
type VariableMultipliersAgentExecutionOptions struct {
	// ContinueOnError - Indicates whether failure on one agent should prevent the phase from running on other agents.
	ContinueOnError *bool `json:"continueOnError,omitempty"`
	// MaxConcurrency - The maximum number of agents to use in parallel.
	MaxConcurrency *int32    `json:"maxConcurrency,omitempty"`
	Multipliers    *[]string `json:"multipliers,omitempty"`
	// Type - Indicates the type of execution options.
	Type *int32 `json:"type,omitempty"`
}

// VariableMultipliersServerExecutionOptions represents options for running a phase based on values
// specified by a list of variables.
type VariableMultipliersServerExecutionOptions struct {
	// ContinueOnError - Indicates whether failure of one job should prevent the phase from running in other jobs.
	ContinueOnError *bool `json:"continueOnError,omitempty"`
	// MaxConcurrency - The maximum number of server jobs to run in parallel.
	MaxConcurrency *int32    `json:"maxConcurrency,omitempty"`
	Multipliers    *[]string `json:"multipliers,omitempty"`
	// Type - The type.
	Type *int32 `json:"type,omitempty"`
}

// VssJSONCollectionWrapper this class is used to serialized collections as a single JSON object on the
// wire, to avoid serializing JSON arrays directly to the client, which can be a security hole
type VssJSONCollectionWrapper struct {
	Value *string `json:"value,omitempty"`
	Count *int32  `json:"count,omitempty"`
}

// VssJSONCollectionWrapperBase ...
type VssJSONCollectionWrapperBase struct {
	Count *int32 `json:"count,omitempty"`
}

// WebAPIConnectedServiceRef ...
type WebAPIConnectedServiceRef struct {
	ID  *string `json:"id,omitempty"`
	URL *string `json:"url,omitempty"`
}

// Workspace represents a workspace mapping.
type Workspace struct {
	Mappings *[]MappingDetails `json:"mappings,omitempty"`
}

// WorkspaceMapping mapping for a workspace
type WorkspaceMapping struct {
	// DefinitionURI - Uri of the associated definition
	DefinitionURI *string `json:"definitionUri,omitempty"`
	// Depth - Depth of this mapping
	Depth *int32 `json:"depth,omitempty"`
	// LocalItem - local location of the definition
	LocalItem *string `json:"localItem,omitempty"`
	// MappingType - type of workspace mapping
	MappingType interface{} `json:"mappingType,omitempty"`
	// ServerItem - Server location of the definition
	ServerItem *string `json:"serverItem,omitempty"`
	// WorkspaceID - Id of the workspace
	WorkspaceID *int32 `json:"workspaceId,omitempty"`
}

// WorkspaceTemplate ...
type WorkspaceTemplate struct {
	// DefinitionURI - Uri of the associated definition
	DefinitionURI *string `json:"definitionUri,omitempty"`
	// LastModifiedBy - The identity that last modified this template
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedDate - The last time this template was modified
	LastModifiedDate *date.Time `json:"lastModifiedDate,omitempty"`
	// Mappings - List of workspace mappings
	Mappings *[]WorkspaceMapping `json:"mappings,omitempty"`
	// WorkspaceID - Id of the workspace for this template
	WorkspaceID *int32 `json:"workspaceId,omitempty"`
}

// XamlBuildControllerReference ...
type XamlBuildControllerReference struct {
	// ID - Id of the resource
	ID *int32 `json:"id,omitempty"`
	// Name - Name of the linked resource (definition name, controller name, etc.)
	Name *string `json:"name,omitempty"`
	// URL - Full http link to the resource
	URL *string `json:"url,omitempty"`
}

// XamlBuildDefinition ...
type XamlBuildDefinition struct {
	Links *ReferenceLinks `json:"_links,omitempty"`
	// BatchSize - Batch size of the definition
	BatchSize *int32  `json:"batchSize,omitempty"`
	BuildArgs *string `json:"buildArgs,omitempty"`
	// ContinuousIntegrationQuietPeriod - The continuous integration quiet period
	ContinuousIntegrationQuietPeriod *int32 `json:"continuousIntegrationQuietPeriod,omitempty"`
	// Controller - The build controller
	Controller *Controller `json:"controller,omitempty"`
	// CreatedOn - The date this definition was created
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// DefaultDropLocation - Default drop location for builds from this definition
	DefaultDropLocation *string `json:"defaultDropLocation,omitempty"`
	// Description - Description of the definition
	Description *string `json:"description,omitempty"`
	// LastBuild - The last build on this definition
	LastBuild *XamlBuildReference `json:"lastBuild,omitempty"`
	// Repository - The repository
	Repository *Repository `json:"repository,omitempty"`
	// SupportedReasons - The reasons supported by the template
	SupportedReasons interface{} `json:"supportedReasons,omitempty"`
	// TriggerType - How builds are triggered from this definition
	TriggerType interface{} `json:"triggerType,omitempty"`
	// CreatedDate - The date this version of the definition was created.
	CreatedDate *date.Time `json:"createdDate,omitempty"`
	// ID - The ID of the referenced definition.
	ID *int32 `json:"id,omitempty"`
	// Name - The name of the referenced definition.
	Name *string `json:"name,omitempty"`
	// Path - The folder path of the definition.
	Path *string `json:"path,omitempty"`
	// Project - A reference to the project.
	Project *TeamProjectReference `json:"project,omitempty"`
	// QueueStatus - A value that indicates whether builds can be queued against this definition.
	QueueStatus interface{} `json:"queueStatus,omitempty"`
	// Revision - The definition revision number.
	Revision *int32 `json:"revision,omitempty"`
	// Type - The type of the definition.
	Type interface{} `json:"type,omitempty"`
	// URI - The definition's URI.
	URI *string `json:"uri,omitempty"`
	// URL - The REST URL of the definition.
	URL *string `json:"url,omitempty"`
}

// XamlBuildReference ...
type XamlBuildReference struct {
	// ID - Id of the resource
	ID *int32 `json:"id,omitempty"`
	// Name - Name of the linked resource (definition name, controller name, etc.)
	Name *string `json:"name,omitempty"`
	// URL - Full http link to the resource
	URL *string `json:"url,omitempty"`
}

// XamlBuildServerReference ...
type XamlBuildServerReference struct {
	// ID - Id of the resource
	ID *int32 `json:"id,omitempty"`
	// Name - Name of the linked resource (definition name, controller name, etc.)
	Name *string `json:"name,omitempty"`
	// URL - Full http link to the resource
	URL *string `json:"url,omitempty"`
}

// XamlDefinitionReference ...
type XamlDefinitionReference struct {
	// ID - Id of the resource
	ID *int32 `json:"id,omitempty"`
	// Name - Name of the linked resource (definition name, controller name, etc.)
	Name *string `json:"name,omitempty"`
	// URL - Full http link to the resource
	URL *string `json:"url,omitempty"`
}

// YamlProcess represents a YAML process.
type YamlProcess struct {
	Errors *[]string `json:"errors,omitempty"`
	// Resources - The resources used by the build definition.
	Resources *ProcessResources `json:"resources,omitempty"`
	// YamlFilename - The YAML filename.
	YamlFilename *string `json:"yamlFilename,omitempty"`
	// Type - The type of the process.
	Type *int32 `json:"type,omitempty"`
}

type Process struct {
	Errors *[]string `json:"errors,omitempty"`
	// Resources - The resources used by the build definition.
	Resources *ProcessResources `json:"resources,omitempty"`
	// YamlFilename - The YAML filename.
	YamlFilename *string `json:"yamlFilename,omitempty"`
	// Type - The type of the process.
	Type *int32 `json:"type,omitempty"`

	Phases *[]Phase `json:"phases,omitempty"`
	// Target - The target for the build process.
	Target *DesignerProcessTarget `json:"target,omitempty"`
}
