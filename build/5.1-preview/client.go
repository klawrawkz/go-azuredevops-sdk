// Package build implements the Azure ARM Build service API version 5.1-preview.
//
//
package build

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/Azure/go-autorest/tracing"
	"github.com/satori/go.uuid"
	"net/http"
)

const (
	// DefaultBaseURI is the default URI used for the service Build
	DefaultBaseURI = "https://dev.azure.com"
)

//// TO ADD
type BuildClient struct {
	BaseClient
}

// NewDatabaseAccountsClient creates an instance of the DatabaseAccountsClient client.
func NewBuildClient() BuildClient {
	return NewBuildClientWithBaseURI(DefaultBaseURI)
}

// NewDatabaseAccountsClientWithBaseURI creates an instance of the DatabaseAccountsClient client.
func NewBuildClientWithBaseURI(baseURI string) BuildClient {
	return BuildClient{NewWithBaseURI(baseURI)}
}

////

// BaseClient is the base client for Build.
type BaseClient struct {
	autorest.Client
	BaseURI string
}

// New creates an instance of the BaseClient client.
func New() BaseClient {
	return NewWithBaseURI(DefaultBaseURI)
}

// NewWithBaseURI creates an instance of the BaseClient client.
func NewWithBaseURI(baseURI string) BaseClient {

	return BaseClient{
		Client:  autorest.NewClientWithUserAgent(UserAgent()),
		BaseURI: baseURI,
	}
}

// AddBuildTag adds a tag to a build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// buildID - the ID of the build.
// tag - the tag to add.
func (client BaseClient) AddBuildTag(ctx context.Context, organization string, project string, buildID int32, tag string) (result ListString, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.AddBuildTag")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.AddBuildTagPreparer(ctx, organization, project, buildID, tag)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AddBuildTag", nil, "Failure preparing request")
		return
	}

	resp, err := client.AddBuildTagSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AddBuildTag", resp, "Failure sending request")
		return
	}

	result, err = client.AddBuildTagResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AddBuildTag", resp, "Failure responding to request")
	}

	return
}

// AddBuildTagPreparer prepares the AddBuildTag request.
func (client BaseClient) AddBuildTagPreparer(ctx context.Context, organization string, project string, buildID int32, tag string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"tag":          autorest.Encode("path", tag),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/tags/{tag}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// AddBuildTagSender sends the AddBuildTag request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) AddBuildTagSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// AddBuildTagResponder handles the response to the AddBuildTag request. The method always
// closes the http.Response Body.
func (client BaseClient) AddBuildTagResponder(resp *http.Response) (result ListString, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// AddBuildTags adds tags to a build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// body - the tags to add.
// project - project ID or project name
// buildID - the ID of the build.
func (client BaseClient) AddBuildTags(ctx context.Context, organization string, body []string, project string, buildID int32) (result ListString, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.AddBuildTags")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("build.BaseClient", "AddBuildTags", err.Error())
	}

	req, err := client.AddBuildTagsPreparer(ctx, organization, body, project, buildID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AddBuildTags", nil, "Failure preparing request")
		return
	}

	resp, err := client.AddBuildTagsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AddBuildTags", resp, "Failure sending request")
		return
	}

	result, err = client.AddBuildTagsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AddBuildTags", resp, "Failure responding to request")
	}

	return
}

// AddBuildTagsPreparer prepares the AddBuildTags request.
func (client BaseClient) AddBuildTagsPreparer(ctx context.Context, organization string, body []string, project string, buildID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/tags", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// AddBuildTagsSender sends the AddBuildTags request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) AddBuildTagsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// AddBuildTagsResponder handles the response to the AddBuildTags request. The method always
// closes the http.Response Body.
func (client BaseClient) AddBuildTagsResponder(resp *http.Response) (result ListString, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// AddDefinitionTag adds a tag to a definition
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// definitionID - the ID of the definition.
// tag - the tag to add.
func (client BaseClient) AddDefinitionTag(ctx context.Context, organization string, project string, definitionID int32, tag string) (result ListString, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.AddDefinitionTag")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.AddDefinitionTagPreparer(ctx, organization, project, definitionID, tag)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AddDefinitionTag", nil, "Failure preparing request")
		return
	}

	resp, err := client.AddDefinitionTagSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AddDefinitionTag", resp, "Failure sending request")
		return
	}

	result, err = client.AddDefinitionTagResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AddDefinitionTag", resp, "Failure responding to request")
	}

	return
}

// AddDefinitionTagPreparer prepares the AddDefinitionTag request.
func (client BaseClient) AddDefinitionTagPreparer(ctx context.Context, organization string, project string, definitionID int32, tag string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definitionId": autorest.Encode("path", definitionID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"tag":          autorest.Encode("path", tag),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/{DefinitionId}/tags/{tag}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// AddDefinitionTagSender sends the AddDefinitionTag request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) AddDefinitionTagSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// AddDefinitionTagResponder handles the response to the AddDefinitionTag request. The method always
// closes the http.Response Body.
func (client BaseClient) AddDefinitionTagResponder(resp *http.Response) (result ListString, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// AddDefinitionTags adds multiple tags to a definition.
// Parameters:
// organization - the name of the Azure DevOps organization.
// body - the tags to add.
// project - project ID or project name
// definitionID - the ID of the definition.
func (client BaseClient) AddDefinitionTags(ctx context.Context, organization string, body []string, project string, definitionID int32) (result ListString, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.AddDefinitionTags")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("build.BaseClient", "AddDefinitionTags", err.Error())
	}

	req, err := client.AddDefinitionTagsPreparer(ctx, organization, body, project, definitionID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AddDefinitionTags", nil, "Failure preparing request")
		return
	}

	resp, err := client.AddDefinitionTagsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AddDefinitionTags", resp, "Failure sending request")
		return
	}

	result, err = client.AddDefinitionTagsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AddDefinitionTags", resp, "Failure responding to request")
	}

	return
}

// AddDefinitionTagsPreparer prepares the AddDefinitionTags request.
func (client BaseClient) AddDefinitionTagsPreparer(ctx context.Context, organization string, body []string, project string, definitionID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definitionId": autorest.Encode("path", definitionID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/{DefinitionId}/tags", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// AddDefinitionTagsSender sends the AddDefinitionTags request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) AddDefinitionTagsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// AddDefinitionTagsResponder handles the response to the AddDefinitionTags request. The method always
// closes the http.Response Body.
func (client BaseClient) AddDefinitionTagsResponder(resp *http.Response) (result ListString, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// AuthorizeDefinitionResources sends the authorize definition resources request.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
func (client BaseClient) AuthorizeDefinitionResources(ctx context.Context, organization string, body []DefinitionResourceReference, project string, definitionID int32) (result ListDefinitionResourceReference, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.AuthorizeDefinitionResources")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("build.BaseClient", "AuthorizeDefinitionResources", err.Error())
	}

	req, err := client.AuthorizeDefinitionResourcesPreparer(ctx, organization, body, project, definitionID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AuthorizeDefinitionResources", nil, "Failure preparing request")
		return
	}

	resp, err := client.AuthorizeDefinitionResourcesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AuthorizeDefinitionResources", resp, "Failure sending request")
		return
	}

	result, err = client.AuthorizeDefinitionResourcesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AuthorizeDefinitionResources", resp, "Failure responding to request")
	}

	return
}

// AuthorizeDefinitionResourcesPreparer prepares the AuthorizeDefinitionResources request.
func (client BaseClient) AuthorizeDefinitionResourcesPreparer(ctx context.Context, organization string, body []DefinitionResourceReference, project string, definitionID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definitionId": autorest.Encode("path", definitionID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/{definitionId}/resources", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// AuthorizeDefinitionResourcesSender sends the AuthorizeDefinitionResources request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) AuthorizeDefinitionResourcesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// AuthorizeDefinitionResourcesResponder handles the response to the AuthorizeDefinitionResources request. The method always
// closes the http.Response Body.
func (client BaseClient) AuthorizeDefinitionResourcesResponder(resp *http.Response) (result ListDefinitionResourceReference, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// AuthorizeProjectResources sends the authorize project resources request.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
func (client BaseClient) AuthorizeProjectResources(ctx context.Context, organization string, body []DefinitionResourceReference, project string) (result ListDefinitionResourceReference, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.AuthorizeProjectResources")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("build.BaseClient", "AuthorizeProjectResources", err.Error())
	}

	req, err := client.AuthorizeProjectResourcesPreparer(ctx, organization, body, project)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AuthorizeProjectResources", nil, "Failure preparing request")
		return
	}

	resp, err := client.AuthorizeProjectResourcesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AuthorizeProjectResources", resp, "Failure sending request")
		return
	}

	result, err = client.AuthorizeProjectResourcesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "AuthorizeProjectResources", resp, "Failure responding to request")
	}

	return
}

// AuthorizeProjectResourcesPreparer prepares the AuthorizeProjectResources request.
func (client BaseClient) AuthorizeProjectResourcesPreparer(ctx context.Context, organization string, body []DefinitionResourceReference, project string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/authorizedresources", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// AuthorizeProjectResourcesSender sends the AuthorizeProjectResources request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) AuthorizeProjectResourcesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// AuthorizeProjectResourcesResponder handles the response to the AuthorizeProjectResources request. The method always
// closes the http.Response Body.
func (client BaseClient) AuthorizeProjectResourcesResponder(resp *http.Response) (result ListDefinitionResourceReference, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateArtifact associates an artifact with a build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// body - the artifact.
// project - project ID or project name
// buildID - the ID of the build.
func (client BaseClient) CreateArtifact(ctx context.Context, organization string, body Artifact, project string, buildID int32) (result Artifact, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CreateArtifact")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.CreateArtifactPreparer(ctx, organization, body, project, buildID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "CreateArtifact", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateArtifactSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "CreateArtifact", resp, "Failure sending request")
		return
	}

	result, err = client.CreateArtifactResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "CreateArtifact", resp, "Failure responding to request")
	}

	return
}

// CreateArtifactPreparer prepares the CreateArtifact request.
func (client BaseClient) CreateArtifactPreparer(ctx context.Context, organization string, body Artifact, project string, buildID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/artifacts", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateArtifactSender sends the CreateArtifact request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateArtifactSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateArtifactResponder handles the response to the CreateArtifact request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateArtifactResponder(resp *http.Response) (result Artifact, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateDefinition creates a new definition.
// Parameters:
// organization - the name of the Azure DevOps organization.
// body - the definition.
// project - project ID or project name
func (client BaseClient) CreateDefinition(ctx context.Context, organization string, body Definition, project string, definitionToCloneID *int32, definitionToCloneRevision *int32) (result Definition, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CreateDefinition")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.CreateDefinitionPreparer(ctx, organization, body, project, definitionToCloneID, definitionToCloneRevision)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "CreateDefinition", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateDefinitionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "CreateDefinition", resp, "Failure sending request")
		return
	}

	result, err = client.CreateDefinitionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "CreateDefinition", resp, "Failure responding to request")
	}

	return
}

// CreateDefinitionPreparer prepares the CreateDefinition request.
func (client BaseClient) CreateDefinitionPreparer(ctx context.Context, organization string, body Definition, project string, definitionToCloneID *int32, definitionToCloneRevision *int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if definitionToCloneID != nil {
		queryParameters["definitionToCloneId"] = autorest.Encode("query", *definitionToCloneID)
	}
	if definitionToCloneRevision != nil {
		queryParameters["definitionToCloneRevision"] = autorest.Encode("query", *definitionToCloneRevision)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateDefinitionSender sends the CreateDefinition request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateDefinitionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateDefinitionResponder handles the response to the CreateDefinition request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateDefinitionResponder(resp *http.Response) (result Definition, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateFolder creates a new folder.
// Parameters:
// organization - the name of the Azure DevOps organization.
// body - the folder.
// project - project ID or project name
// pathParameter - the full path of the folder.
func (client BaseClient) CreateFolder(ctx context.Context, organization string, body Folder, project string, pathParameter string) (result Folder, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CreateFolder")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.CreateFolderPreparer(ctx, organization, body, project, pathParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "CreateFolder", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateFolderSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "CreateFolder", resp, "Failure sending request")
		return
	}

	result, err = client.CreateFolderResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "CreateFolder", resp, "Failure responding to request")
	}

	return
}

// CreateFolderPreparer prepares the CreateFolder request.
func (client BaseClient) CreateFolderPreparer(ctx context.Context, organization string, body Folder, project string, pathParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"path":         autorest.Encode("path", pathParameter),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/folders/{path}", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateFolderSender sends the CreateFolder request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateFolderSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateFolderResponder handles the response to the CreateFolder request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateFolderResponder(resp *http.Response) (result Folder, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteBuild deletes a build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// buildID - the ID of the build.
func (client BaseClient) DeleteBuild(ctx context.Context, organization string, project string, buildID int32) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteBuild")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteBuildPreparer(ctx, organization, project, buildID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteBuild", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteBuildSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteBuild", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteBuildResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteBuild", resp, "Failure responding to request")
	}

	return
}

// DeleteBuildPreparer prepares the DeleteBuild request.
func (client BaseClient) DeleteBuildPreparer(ctx context.Context, organization string, project string, buildID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteBuildSender sends the DeleteBuild request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteBuildSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteBuildResponder handles the response to the DeleteBuild request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteBuildResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteBuildTag removes a tag from a build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// buildID - the ID of the build.
// tag - the tag to remove.
func (client BaseClient) DeleteBuildTag(ctx context.Context, organization string, project string, buildID int32, tag string) (result ListString, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteBuildTag")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteBuildTagPreparer(ctx, organization, project, buildID, tag)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteBuildTag", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteBuildTagSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteBuildTag", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteBuildTagResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteBuildTag", resp, "Failure responding to request")
	}

	return
}

// DeleteBuildTagPreparer prepares the DeleteBuildTag request.
func (client BaseClient) DeleteBuildTagPreparer(ctx context.Context, organization string, project string, buildID int32, tag string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"tag":          autorest.Encode("path", tag),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/tags/{tag}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteBuildTagSender sends the DeleteBuildTag request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteBuildTagSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteBuildTagResponder handles the response to the DeleteBuildTag request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteBuildTagResponder(resp *http.Response) (result ListString, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteDefinition deletes a definition and all associated builds.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// definitionID - the ID of the definition.
func (client BaseClient) DeleteDefinition(ctx context.Context, organization string, project string, definitionID int32) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteDefinition")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteDefinitionPreparer(ctx, organization, project, definitionID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteDefinition", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteDefinitionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteDefinition", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteDefinitionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteDefinition", resp, "Failure responding to request")
	}

	return
}

// DeleteDefinitionPreparer prepares the DeleteDefinition request.
func (client BaseClient) DeleteDefinitionPreparer(ctx context.Context, organization string, project string, definitionID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definitionId": autorest.Encode("path", definitionID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/{definitionId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteDefinitionSender sends the DeleteDefinition request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteDefinitionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteDefinitionResponder handles the response to the DeleteDefinition request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteDefinitionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteDefinitionTag removes a tag from a definition.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// definitionID - the ID of the definition.
// tag - the tag to remove.
func (client BaseClient) DeleteDefinitionTag(ctx context.Context, organization string, project string, definitionID int32, tag string) (result ListString, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteDefinitionTag")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteDefinitionTagPreparer(ctx, organization, project, definitionID, tag)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteDefinitionTag", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteDefinitionTagSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteDefinitionTag", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteDefinitionTagResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteDefinitionTag", resp, "Failure responding to request")
	}

	return
}

// DeleteDefinitionTagPreparer prepares the DeleteDefinitionTag request.
func (client BaseClient) DeleteDefinitionTagPreparer(ctx context.Context, organization string, project string, definitionID int32, tag string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definitionId": autorest.Encode("path", definitionID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"tag":          autorest.Encode("path", tag),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/{DefinitionId}/tags/{tag}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteDefinitionTagSender sends the DeleteDefinitionTag request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteDefinitionTagSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteDefinitionTagResponder handles the response to the DeleteDefinitionTag request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteDefinitionTagResponder(resp *http.Response) (result ListString, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteFolder deletes a definition folder. Definitions and their corresponding builds will also be deleted.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// pathParameter - the full path to the folder.
func (client BaseClient) DeleteFolder(ctx context.Context, organization string, project string, pathParameter string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteFolder")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteFolderPreparer(ctx, organization, project, pathParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteFolder", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteFolderSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteFolder", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteFolderResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteFolder", resp, "Failure responding to request")
	}

	return
}

// DeleteFolderPreparer prepares the DeleteFolder request.
func (client BaseClient) DeleteFolderPreparer(ctx context.Context, organization string, project string, pathParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"path":         autorest.Encode("path", pathParameter),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/folders/{path}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteFolderSender sends the DeleteFolder request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteFolderSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteFolderResponder handles the response to the DeleteFolder request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteFolderResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteTemplate deletes a build definition template.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// templateID - the ID of the template.
func (client BaseClient) DeleteTemplate(ctx context.Context, organization string, project string, templateID string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteTemplate")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteTemplatePreparer(ctx, organization, project, templateID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteTemplate", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteTemplateSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteTemplate", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteTemplateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "DeleteTemplate", resp, "Failure responding to request")
	}

	return
}

// DeleteTemplatePreparer prepares the DeleteTemplate request.
func (client BaseClient) DeleteTemplatePreparer(ctx context.Context, organization string, project string, templateID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"templateId":   autorest.Encode("path", templateID),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/templates/{templateId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteTemplateSender sends the DeleteTemplate request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteTemplateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteTemplateResponder handles the response to the DeleteTemplate request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteTemplateResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// GetArtifact gets a specific artifact for a build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// buildID - the ID of the build.
// artifactName - the name of the artifact.
func (client BaseClient) GetArtifact(ctx context.Context, organization string, project string, buildID int32, artifactName string) (result Artifact, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetArtifact")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetArtifactPreparer(ctx, organization, project, buildID, artifactName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetArtifact", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetArtifactSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetArtifact", resp, "Failure sending request")
		return
	}

	result, err = client.GetArtifactResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetArtifact", resp, "Failure responding to request")
	}

	return
}

// GetArtifactPreparer prepares the GetArtifact request.
func (client BaseClient) GetArtifactPreparer(ctx context.Context, organization string, project string, buildID int32, artifactName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version":  APIVersion,
		"artifactName": autorest.Encode("query", artifactName),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/artifacts", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetArtifactSender sends the GetArtifact request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetArtifactSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetArtifactResponder handles the response to the GetArtifact request. The method always
// closes the http.Response Body.
func (client BaseClient) GetArtifactResponder(resp *http.Response) (result Artifact, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetArtifacts gets all artifacts for a build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// buildID - the ID of the build.
func (client BaseClient) GetArtifacts(ctx context.Context, organization string, project string, buildID int32) (result ListArtifact, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetArtifacts")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetArtifactsPreparer(ctx, organization, project, buildID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetArtifacts", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetArtifactsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetArtifacts", resp, "Failure sending request")
		return
	}

	result, err = client.GetArtifactsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetArtifacts", resp, "Failure responding to request")
	}

	return
}

// GetArtifactsPreparer prepares the GetArtifacts request.
func (client BaseClient) GetArtifactsPreparer(ctx context.Context, organization string, project string, buildID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/artifacts", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetArtifactsSender sends the GetArtifacts request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetArtifactsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetArtifactsResponder handles the response to the GetArtifacts request. The method always
// closes the http.Response Body.
func (client BaseClient) GetArtifactsResponder(resp *http.Response) (result ListArtifact, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetAttachment gets a specific attachment.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// buildID - the ID of the build.
// timelineID - the ID of the timeline.
// recordID - the ID of the timeline record.
// typeParameter - the type of the attachment.
// name - the name of the attachment.
func (client BaseClient) GetAttachment(ctx context.Context, organization string, project string, buildID int32, timelineID uuid.UUID, recordID uuid.UUID, typeParameter string, name string) (result String, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetAttachment")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetAttachmentPreparer(ctx, organization, project, buildID, timelineID, recordID, typeParameter, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetAttachment", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetAttachmentSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetAttachment", resp, "Failure sending request")
		return
	}

	result, err = client.GetAttachmentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetAttachment", resp, "Failure responding to request")
	}

	return
}

// GetAttachmentPreparer prepares the GetAttachment request.
func (client BaseClient) GetAttachmentPreparer(ctx context.Context, organization string, project string, buildID int32, timelineID uuid.UUID, recordID uuid.UUID, typeParameter string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"name":         autorest.Encode("path", name),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"recordId":     autorest.Encode("path", recordID),
		"timelineId":   autorest.Encode("path", timelineID),
		"type":         autorest.Encode("path", typeParameter),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/{timelineId}/{recordId}/attachments/{type}/{name}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetAttachmentSender sends the GetAttachment request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetAttachmentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetAttachmentResponder handles the response to the GetAttachment request. The method always
// closes the http.Response Body.
func (client BaseClient) GetAttachmentResponder(resp *http.Response) (result String, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetAttachments gets the list of attachments of a specific type that are associated with a build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// buildID - the ID of the build.
// typeParameter - the type of attachment.
func (client BaseClient) GetAttachments(ctx context.Context, organization string, project string, buildID int32, typeParameter string) (result ListAttachment, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetAttachments")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetAttachmentsPreparer(ctx, organization, project, buildID, typeParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetAttachments", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetAttachmentsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetAttachments", resp, "Failure sending request")
		return
	}

	result, err = client.GetAttachmentsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetAttachments", resp, "Failure responding to request")
	}

	return
}

// GetAttachmentsPreparer prepares the GetAttachments request.
func (client BaseClient) GetAttachmentsPreparer(ctx context.Context, organization string, project string, buildID int32, typeParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"type":         autorest.Encode("path", typeParameter),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/attachments/{type}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetAttachmentsSender sends the GetAttachments request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetAttachmentsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetAttachmentsResponder handles the response to the GetAttachments request. The method always
// closes the http.Response Body.
func (client BaseClient) GetAttachmentsResponder(resp *http.Response) (result ListAttachment, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBadge use StatusBadgeController.GetStatusBadge
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - the project ID or name.
// definitionID - the ID of the definition.
// branchName - the name of the branch.
func (client BaseClient) GetBadge(ctx context.Context, organization string, project uuid.UUID, definitionID int32, branchName string) (result String, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBadge")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBadgePreparer(ctx, organization, project, definitionID, branchName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBadge", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBadgeSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBadge", resp, "Failure sending request")
		return
	}

	result, err = client.GetBadgeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBadge", resp, "Failure responding to request")
	}

	return
}

// GetBadgePreparer prepares the GetBadge request.
func (client BaseClient) GetBadgePreparer(ctx context.Context, organization string, project uuid.UUID, definitionID int32, branchName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definitionId": autorest.Encode("path", definitionID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(branchName) > 0 {
		queryParameters["branchName"] = autorest.Encode("query", branchName)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/_apis/public/build/definitions/{project}/{definitionId}/badge", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBadgeSender sends the GetBadge request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBadgeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBadgeResponder handles the response to the GetBadge request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBadgeResponder(resp *http.Response) (result String, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuild gets a build
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
func (client BaseClient) GetBuild(ctx context.Context, organization string, project string, buildID int32, propertyFilters string) (result Model, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuild")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBuildPreparer(ctx, organization, project, buildID, propertyFilters)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuild", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuild", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuild", resp, "Failure responding to request")
	}

	return
}

// GetBuildPreparer prepares the GetBuild request.
func (client BaseClient) GetBuildPreparer(ctx context.Context, organization string, project string, buildID int32, propertyFilters string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(propertyFilters) > 0 {
		queryParameters["propertyFilters"] = autorest.Encode("query", propertyFilters)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildSender sends the GetBuild request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildResponder handles the response to the GetBuild request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildResponder(resp *http.Response) (result Model, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuildBadge gets a badge that indicates the status of the most recent build for the specified branch.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// repoType - the repository type.
// repoID - the repository ID.
// branchName - the branch name.
func (client BaseClient) GetBuildBadge(ctx context.Context, organization string, project string, repoType string, repoID string, branchName string) (result String, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuildBadge")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBuildBadgePreparer(ctx, organization, project, repoType, repoID, branchName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildBadge", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildBadgeSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildBadge", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildBadgeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildBadge", resp, "Failure responding to request")
	}

	return
}

// GetBuildBadgePreparer prepares the GetBuildBadge request.
func (client BaseClient) GetBuildBadgePreparer(ctx context.Context, organization string, project string, repoType string, repoID string, branchName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"repoType":     autorest.Encode("path", repoType),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(repoID) > 0 {
		queryParameters["repoId"] = autorest.Encode("query", repoID)
	}
	if len(branchName) > 0 {
		queryParameters["branchName"] = autorest.Encode("query", branchName)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/repos/{repoType}/badge", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildBadgeSender sends the GetBuildBadge request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildBadgeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildBadgeResponder handles the response to the GetBuildBadge request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildBadgeResponder(resp *http.Response) (result String, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuildChanges gets the changes associated with a build
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// top - the maximum number of changes to return
func (client BaseClient) GetBuildChanges(ctx context.Context, organization string, project string, buildID int32, continuationToken string, top *int32, includeSourceChange *bool) (result ListChange, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuildChanges")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBuildChangesPreparer(ctx, organization, project, buildID, continuationToken, top, includeSourceChange)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildChanges", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildChangesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildChanges", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildChangesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildChanges", resp, "Failure responding to request")
	}

	return
}

// GetBuildChangesPreparer prepares the GetBuildChanges request.
func (client BaseClient) GetBuildChangesPreparer(ctx context.Context, organization string, project string, buildID int32, continuationToken string, top *int32, includeSourceChange *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(continuationToken) > 0 {
		queryParameters["continuationToken"] = autorest.Encode("query", continuationToken)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if includeSourceChange != nil {
		queryParameters["includeSourceChange"] = autorest.Encode("query", *includeSourceChange)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/changes", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildChangesSender sends the GetBuildChanges request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildChangesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildChangesResponder handles the response to the GetBuildChanges request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildChangesResponder(resp *http.Response) (result ListChange, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuildController gets a controller
// Parameters:
// organization - the name of the Azure DevOps organization.
func (client BaseClient) GetBuildController(ctx context.Context, organization string, controllerID int32) (result Controller, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuildController")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBuildControllerPreparer(ctx, organization, controllerID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildController", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildControllerSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildController", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildControllerResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildController", resp, "Failure responding to request")
	}

	return
}

// GetBuildControllerPreparer prepares the GetBuildController request.
func (client BaseClient) GetBuildControllerPreparer(ctx context.Context, organization string, controllerID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"controllerId": autorest.Encode("path", controllerID),
		"organization": autorest.Encode("path", organization),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/_apis/build/controllers/{controllerId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildControllerSender sends the GetBuildController request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildControllerSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildControllerResponder handles the response to the GetBuildController request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildControllerResponder(resp *http.Response) (result Controller, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuildControllers gets controller, optionally filtered by name
// Parameters:
// organization - the name of the Azure DevOps organization.
func (client BaseClient) GetBuildControllers(ctx context.Context, organization string, name string) (result ListController, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuildControllers")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBuildControllersPreparer(ctx, organization, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildControllers", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildControllersSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildControllers", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildControllersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildControllers", resp, "Failure responding to request")
	}

	return
}

// GetBuildControllersPreparer prepares the GetBuildControllers request.
func (client BaseClient) GetBuildControllersPreparer(ctx context.Context, organization string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(name) > 0 {
		queryParameters["name"] = autorest.Encode("query", name)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/_apis/build/controllers", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildControllersSender sends the GetBuildControllers request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildControllersSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildControllersResponder handles the response to the GetBuildControllers request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildControllersResponder(resp *http.Response) (result ListController, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuildLog gets an individual log file for a build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// buildID - the ID of the build.
// logID - the ID of the log file.
// startLine - the start line.
// endLine - the end line.
func (client BaseClient) GetBuildLog(ctx context.Context, organization string, project string, buildID int32, logID int32, startLine *int64, endLine *int64) (result String, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuildLog")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBuildLogPreparer(ctx, organization, project, buildID, logID, startLine, endLine)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildLog", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildLogSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildLog", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildLogResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildLog", resp, "Failure responding to request")
	}

	return
}

// GetBuildLogPreparer prepares the GetBuildLog request.
func (client BaseClient) GetBuildLogPreparer(ctx context.Context, organization string, project string, buildID int32, logID int32, startLine *int64, endLine *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"logId":        autorest.Encode("path", logID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if startLine != nil {
		queryParameters["startLine"] = autorest.Encode("query", *startLine)
	}
	if endLine != nil {
		queryParameters["endLine"] = autorest.Encode("query", *endLine)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/logs/{logId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildLogSender sends the GetBuildLog request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildLogSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildLogResponder handles the response to the GetBuildLog request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildLogResponder(resp *http.Response) (result String, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuildLogs gets the logs for a build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// buildID - the ID of the build.
func (client BaseClient) GetBuildLogs(ctx context.Context, organization string, project string, buildID int32) (result ListLog, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuildLogs")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBuildLogsPreparer(ctx, organization, project, buildID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildLogs", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildLogsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildLogs", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildLogsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildLogs", resp, "Failure responding to request")
	}

	return
}

// GetBuildLogsPreparer prepares the GetBuildLogs request.
func (client BaseClient) GetBuildLogsPreparer(ctx context.Context, organization string, project string, buildID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/logs", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildLogsSender sends the GetBuildLogs request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildLogsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildLogsResponder handles the response to the GetBuildLogs request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildLogsResponder(resp *http.Response) (result ListLog, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuildOptionDefinitions gets all build definition options supported by the system.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
func (client BaseClient) GetBuildOptionDefinitions(ctx context.Context, organization string, project string) (result ListOptionDefinition, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuildOptionDefinitions")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBuildOptionDefinitionsPreparer(ctx, organization, project)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildOptionDefinitions", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildOptionDefinitionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildOptionDefinitions", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildOptionDefinitionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildOptionDefinitions", resp, "Failure responding to request")
	}

	return
}

// GetBuildOptionDefinitionsPreparer prepares the GetBuildOptionDefinitions request.
func (client BaseClient) GetBuildOptionDefinitionsPreparer(ctx context.Context, organization string, project string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/options", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildOptionDefinitionsSender sends the GetBuildOptionDefinitions request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildOptionDefinitionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildOptionDefinitionsResponder handles the response to the GetBuildOptionDefinitions request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildOptionDefinitionsResponder(resp *http.Response) (result ListOptionDefinition, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuildProperties gets properties for a build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// buildID - the ID of the build.
// filter - a comma-delimited list of properties. If specified, filters to these specific properties.
func (client BaseClient) GetBuildProperties(ctx context.Context, organization string, project string, buildID int32, filter string) (result PropertiesCollection, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuildProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBuildPropertiesPreparer(ctx, organization, project, buildID, filter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildPropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildProperties", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildPropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildProperties", resp, "Failure responding to request")
	}

	return
}

// GetBuildPropertiesPreparer prepares the GetBuildProperties request.
func (client BaseClient) GetBuildPropertiesPreparer(ctx context.Context, organization string, project string, buildID int32, filter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["filter"] = autorest.Encode("query", filter)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/properties", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildPropertiesSender sends the GetBuildProperties request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildPropertiesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildPropertiesResponder handles the response to the GetBuildProperties request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildPropertiesResponder(resp *http.Response) (result PropertiesCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuildReport gets a build report.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// buildID - the ID of the build.
func (client BaseClient) GetBuildReport(ctx context.Context, organization string, project string, buildID int32, typeParameter string) (result ReportMetadata, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuildReport")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBuildReportPreparer(ctx, organization, project, buildID, typeParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildReport", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildReportSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildReport", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildReportResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildReport", resp, "Failure responding to request")
	}

	return
}

// GetBuildReportPreparer prepares the GetBuildReport request.
func (client BaseClient) GetBuildReportPreparer(ctx context.Context, organization string, project string, buildID int32, typeParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(typeParameter) > 0 {
		queryParameters["type"] = autorest.Encode("query", typeParameter)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/report", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildReportSender sends the GetBuildReport request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildReportSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildReportResponder handles the response to the GetBuildReport request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildReportResponder(resp *http.Response) (result ReportMetadata, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuilds gets a list of builds.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// definitions - a comma-delimited list of definition IDs. If specified, filters to builds for these
// definitions.
// queues - a comma-delimited list of queue IDs. If specified, filters to builds that ran against these queues.
// buildNumber - if specified, filters to builds that match this build number. Append * to do a prefix search.
// minTime - if specified, filters to builds that finished/started/queued after this date based on the
// queryOrder specified.
// maxTime - if specified, filters to builds that finished/started/queued before this date based on the
// queryOrder specified.
// requestedFor - if specified, filters to builds requested for the specified user.
// reasonFilter - if specified, filters to builds that match this reason.
// statusFilter - if specified, filters to builds that match this status.
// resultFilter - if specified, filters to builds that match this result.
// tagFilters - a comma-delimited list of tags. If specified, filters to builds that have the specified tags.
// properties - a comma-delimited list of properties to retrieve.
// top - the maximum number of builds to return.
// continuationToken - a continuation token, returned by a previous call to this method, that can be used to
// return the next set of builds.
// maxBuildsPerDefinition - the maximum number of builds to return per definition.
// deletedFilter - indicates whether to exclude, include, or only return deleted builds.
// queryOrder - the order in which builds should be returned.
// branchName - if specified, filters to builds that built branches that built this branch.
// buildIds - a comma-delimited list that specifies the IDs of builds to retrieve.
// repositoryID - if specified, filters to builds that built from this repository.
// repositoryType - if specified, filters to builds that built from repositories of this type.
func (client BaseClient) GetBuilds(ctx context.Context, organization string, project string, definitions string, queues string, buildNumber string, minTime *date.Time, maxTime *date.Time, requestedFor string, reasonFilter Reason, statusFilter Status, resultFilter Result, tagFilters string, properties string, top *int32, continuationToken string, maxBuildsPerDefinition *int32, deletedFilter QueryDeletedOption, queryOrder QueryOrder, branchName string, buildIds string, repositoryID string, repositoryType string) (result ListModel, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuilds")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBuildsPreparer(ctx, organization, project, definitions, queues, buildNumber, minTime, maxTime, requestedFor, reasonFilter, statusFilter, resultFilter, tagFilters, properties, top, continuationToken, maxBuildsPerDefinition, deletedFilter, queryOrder, branchName, buildIds, repositoryID, repositoryType)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuilds", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuilds", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuilds", resp, "Failure responding to request")
	}

	return
}

// GetBuildsPreparer prepares the GetBuilds request.
func (client BaseClient) GetBuildsPreparer(ctx context.Context, organization string, project string, definitions string, queues string, buildNumber string, minTime *date.Time, maxTime *date.Time, requestedFor string, reasonFilter Reason, statusFilter Status, resultFilter Result, tagFilters string, properties string, top *int32, continuationToken string, maxBuildsPerDefinition *int32, deletedFilter QueryDeletedOption, queryOrder QueryOrder, branchName string, buildIds string, repositoryID string, repositoryType string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(definitions) > 0 {
		queryParameters["definitions"] = autorest.Encode("query", definitions)
	}
	if len(queues) > 0 {
		queryParameters["queues"] = autorest.Encode("query", queues)
	}
	if len(buildNumber) > 0 {
		queryParameters["buildNumber"] = autorest.Encode("query", buildNumber)
	}
	if minTime != nil {
		queryParameters["minTime"] = autorest.Encode("query", *minTime)
	}
	if maxTime != nil {
		queryParameters["maxTime"] = autorest.Encode("query", *maxTime)
	}
	if len(requestedFor) > 0 {
		queryParameters["requestedFor"] = autorest.Encode("query", requestedFor)
	}
	if len(string(reasonFilter)) > 0 {
		queryParameters["reasonFilter"] = autorest.Encode("query", reasonFilter)
	}
	if len(string(statusFilter)) > 0 {
		queryParameters["statusFilter"] = autorest.Encode("query", statusFilter)
	}
	if len(string(resultFilter)) > 0 {
		queryParameters["resultFilter"] = autorest.Encode("query", resultFilter)
	}
	if len(tagFilters) > 0 {
		queryParameters["tagFilters"] = autorest.Encode("query", tagFilters)
	}
	if len(properties) > 0 {
		queryParameters["properties"] = autorest.Encode("query", properties)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if len(continuationToken) > 0 {
		queryParameters["continuationToken"] = autorest.Encode("query", continuationToken)
	}
	if maxBuildsPerDefinition != nil {
		queryParameters["maxBuildsPerDefinition"] = autorest.Encode("query", *maxBuildsPerDefinition)
	}
	if len(string(deletedFilter)) > 0 {
		queryParameters["deletedFilter"] = autorest.Encode("query", deletedFilter)
	}
	if len(string(queryOrder)) > 0 {
		queryParameters["queryOrder"] = autorest.Encode("query", queryOrder)
	}
	if len(branchName) > 0 {
		queryParameters["branchName"] = autorest.Encode("query", branchName)
	}
	if len(buildIds) > 0 {
		queryParameters["buildIds"] = autorest.Encode("query", buildIds)
	}
	if len(repositoryID) > 0 {
		queryParameters["repositoryId"] = autorest.Encode("query", repositoryID)
	}
	if len(repositoryType) > 0 {
		queryParameters["repositoryType"] = autorest.Encode("query", repositoryType)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildsSender sends the GetBuilds request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildsResponder handles the response to the GetBuilds request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildsResponder(resp *http.Response) (result ListModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuildSettings gets the build settings.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
func (client BaseClient) GetBuildSettings(ctx context.Context, organization string, project string) (result Settings, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuildSettings")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBuildSettingsPreparer(ctx, organization, project)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildSettings", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildSettingsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildSettings", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildSettingsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildSettings", resp, "Failure responding to request")
	}

	return
}

// GetBuildSettingsPreparer prepares the GetBuildSettings request.
func (client BaseClient) GetBuildSettingsPreparer(ctx context.Context, organization string, project string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/settings", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildSettingsSender sends the GetBuildSettings request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildSettingsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildSettingsResponder handles the response to the GetBuildSettings request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildSettingsResponder(resp *http.Response) (result Settings, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuildTags gets the tags for a build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// buildID - the ID of the build.
func (client BaseClient) GetBuildTags(ctx context.Context, organization string, project string, buildID int32) (result ListString, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuildTags")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBuildTagsPreparer(ctx, organization, project, buildID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildTags", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildTagsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildTags", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildTagsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildTags", resp, "Failure responding to request")
	}

	return
}

// GetBuildTagsPreparer prepares the GetBuildTags request.
func (client BaseClient) GetBuildTagsPreparer(ctx context.Context, organization string, project string, buildID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/tags", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildTagsSender sends the GetBuildTags request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildTagsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildTagsResponder handles the response to the GetBuildTags request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildTagsResponder(resp *http.Response) (result ListString, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuildTimeline gets details for a build
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
func (client BaseClient) GetBuildTimeline(ctx context.Context, organization string, project string, buildID int32, timelineID uuid.UUID, changeID *int32, planID *uuid.UUID) (result Timeline, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuildTimeline")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBuildTimelinePreparer(ctx, organization, project, buildID, timelineID, changeID, planID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildTimeline", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildTimelineSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildTimeline", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildTimelineResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildTimeline", resp, "Failure responding to request")
	}

	return
}

// GetBuildTimelinePreparer prepares the GetBuildTimeline request.
func (client BaseClient) GetBuildTimelinePreparer(ctx context.Context, organization string, project string, buildID int32, timelineID uuid.UUID, changeID *int32, planID *uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"timelineId":   autorest.Encode("path", timelineID),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if changeID != nil {
		queryParameters["changeId"] = autorest.Encode("query", *changeID)
	}
	if planID != nil {
		queryParameters["planId"] = autorest.Encode("query", *planID)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/timeline/{timelineId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildTimelineSender sends the GetBuildTimeline request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildTimelineSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildTimelineResponder handles the response to the GetBuildTimeline request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildTimelineResponder(resp *http.Response) (result Timeline, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuildWorkItemsRefs gets the work items associated with a build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// buildID - the ID of the build.
// top - the maximum number of work items to return.
func (client BaseClient) GetBuildWorkItemsRefs(ctx context.Context, organization string, project string, buildID int32, top *int32) (result ListResourceRef, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuildWorkItemsRefs")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBuildWorkItemsRefsPreparer(ctx, organization, project, buildID, top)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildWorkItemsRefs", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildWorkItemsRefsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildWorkItemsRefs", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildWorkItemsRefsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildWorkItemsRefs", resp, "Failure responding to request")
	}

	return
}

// GetBuildWorkItemsRefsPreparer prepares the GetBuildWorkItemsRefs request.
func (client BaseClient) GetBuildWorkItemsRefsPreparer(ctx context.Context, organization string, project string, buildID int32, top *int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/workitems", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildWorkItemsRefsSender sends the GetBuildWorkItemsRefs request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildWorkItemsRefsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildWorkItemsRefsResponder handles the response to the GetBuildWorkItemsRefs request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildWorkItemsRefsResponder(resp *http.Response) (result ListResourceRef, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBuildWorkItemsRefsFromCommits gets the work items associated with a build, filtered to specific commits.
// Parameters:
// organization - the name of the Azure DevOps organization.
// body - a comma-delimited list of commit IDs.
// project - project ID or project name
// buildID - the ID of the build.
// top - the maximum number of work items to return, or the number of commits to consider if no commit IDs are
// specified.
func (client BaseClient) GetBuildWorkItemsRefsFromCommits(ctx context.Context, organization string, body []string, project string, buildID int32, top *int32) (result ListResourceRef, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetBuildWorkItemsRefsFromCommits")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("build.BaseClient", "GetBuildWorkItemsRefsFromCommits", err.Error())
	}

	req, err := client.GetBuildWorkItemsRefsFromCommitsPreparer(ctx, organization, body, project, buildID, top)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildWorkItemsRefsFromCommits", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBuildWorkItemsRefsFromCommitsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildWorkItemsRefsFromCommits", resp, "Failure sending request")
		return
	}

	result, err = client.GetBuildWorkItemsRefsFromCommitsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetBuildWorkItemsRefsFromCommits", resp, "Failure responding to request")
	}

	return
}

// GetBuildWorkItemsRefsFromCommitsPreparer prepares the GetBuildWorkItemsRefsFromCommits request.
func (client BaseClient) GetBuildWorkItemsRefsFromCommitsPreparer(ctx context.Context, organization string, body []string, project string, buildID int32, top *int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/workitems", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBuildWorkItemsRefsFromCommitsSender sends the GetBuildWorkItemsRefsFromCommits request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetBuildWorkItemsRefsFromCommitsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBuildWorkItemsRefsFromCommitsResponder handles the response to the GetBuildWorkItemsRefsFromCommits request. The method always
// closes the http.Response Body.
func (client BaseClient) GetBuildWorkItemsRefsFromCommitsResponder(resp *http.Response) (result ListResourceRef, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetChangesBetweenBuilds gets the changes made to the repository between two given builds.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// fromBuildID - the ID of the first build.
// toBuildID - the ID of the last build.
// top - the maximum number of changes to return.
func (client BaseClient) GetChangesBetweenBuilds(ctx context.Context, organization string, project string, fromBuildID *int32, toBuildID *int32, top *int32) (result ListChange, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetChangesBetweenBuilds")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetChangesBetweenBuildsPreparer(ctx, organization, project, fromBuildID, toBuildID, top)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetChangesBetweenBuilds", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetChangesBetweenBuildsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetChangesBetweenBuilds", resp, "Failure sending request")
		return
	}

	result, err = client.GetChangesBetweenBuildsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetChangesBetweenBuilds", resp, "Failure responding to request")
	}

	return
}

// GetChangesBetweenBuildsPreparer prepares the GetChangesBetweenBuilds request.
func (client BaseClient) GetChangesBetweenBuildsPreparer(ctx context.Context, organization string, project string, fromBuildID *int32, toBuildID *int32, top *int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if fromBuildID != nil {
		queryParameters["fromBuildId"] = autorest.Encode("query", *fromBuildID)
	}
	if toBuildID != nil {
		queryParameters["toBuildId"] = autorest.Encode("query", *toBuildID)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/changes", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetChangesBetweenBuildsSender sends the GetChangesBetweenBuilds request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetChangesBetweenBuildsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetChangesBetweenBuildsResponder handles the response to the GetChangesBetweenBuilds request. The method always
// closes the http.Response Body.
func (client BaseClient) GetChangesBetweenBuildsResponder(resp *http.Response) (result ListChange, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDefinition gets a definition, optionally at a specific revision.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// definitionID - the ID of the definition.
// revision - the revision number to retrieve. If this is not specified, the latest version will be returned.
// minMetricsTime - if specified, indicates the date from which metrics should be included.
// propertyFilters - a comma-delimited list of properties to include in the results.
func (client BaseClient) GetDefinition(ctx context.Context, organization string, project string, definitionID int32, revision *int32, minMetricsTime *date.Time, propertyFilters string, includeLatestBuilds *bool) (result Definition, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetDefinition")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetDefinitionPreparer(ctx, organization, project, definitionID, revision, minMetricsTime, propertyFilters, includeLatestBuilds)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinition", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDefinitionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinition", resp, "Failure sending request")
		return
	}

	result, err = client.GetDefinitionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinition", resp, "Failure responding to request")
	}

	return
}

// GetDefinitionPreparer prepares the GetDefinition request.
func (client BaseClient) GetDefinitionPreparer(ctx context.Context, organization string, project string, definitionID int32, revision *int32, minMetricsTime *date.Time, propertyFilters string, includeLatestBuilds *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definitionId": autorest.Encode("path", definitionID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if revision != nil {
		queryParameters["revision"] = autorest.Encode("query", *revision)
	}
	if minMetricsTime != nil {
		queryParameters["minMetricsTime"] = autorest.Encode("query", *minMetricsTime)
	}
	if len(propertyFilters) > 0 {
		queryParameters["propertyFilters"] = autorest.Encode("query", propertyFilters)
	}
	if includeLatestBuilds != nil {
		queryParameters["includeLatestBuilds"] = autorest.Encode("query", *includeLatestBuilds)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/{definitionId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDefinitionSender sends the GetDefinition request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDefinitionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDefinitionResponder handles the response to the GetDefinition request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDefinitionResponder(resp *http.Response) (result Definition, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDefinitionMetrics gets build metrics for a definition.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// definitionID - the ID of the definition.
// minMetricsTime - the date from which to calculate metrics.
func (client BaseClient) GetDefinitionMetrics(ctx context.Context, organization string, project string, definitionID int32, minMetricsTime *date.Time) (result ListMetric, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetDefinitionMetrics")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetDefinitionMetricsPreparer(ctx, organization, project, definitionID, minMetricsTime)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitionMetrics", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDefinitionMetricsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitionMetrics", resp, "Failure sending request")
		return
	}

	result, err = client.GetDefinitionMetricsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitionMetrics", resp, "Failure responding to request")
	}

	return
}

// GetDefinitionMetricsPreparer prepares the GetDefinitionMetrics request.
func (client BaseClient) GetDefinitionMetricsPreparer(ctx context.Context, organization string, project string, definitionID int32, minMetricsTime *date.Time) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definitionId": autorest.Encode("path", definitionID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if minMetricsTime != nil {
		queryParameters["minMetricsTime"] = autorest.Encode("query", *minMetricsTime)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/{definitionId}/metrics", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDefinitionMetricsSender sends the GetDefinitionMetrics request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDefinitionMetricsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDefinitionMetricsResponder handles the response to the GetDefinitionMetrics request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDefinitionMetricsResponder(resp *http.Response) (result ListMetric, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDefinitionProperties gets properties for a definition.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// definitionID - the ID of the definition.
// filter - a comma-delimited list of properties. If specified, filters to these specific properties.
func (client BaseClient) GetDefinitionProperties(ctx context.Context, organization string, project string, definitionID int32, filter string) (result PropertiesCollection, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetDefinitionProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetDefinitionPropertiesPreparer(ctx, organization, project, definitionID, filter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitionProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDefinitionPropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitionProperties", resp, "Failure sending request")
		return
	}

	result, err = client.GetDefinitionPropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitionProperties", resp, "Failure responding to request")
	}

	return
}

// GetDefinitionPropertiesPreparer prepares the GetDefinitionProperties request.
func (client BaseClient) GetDefinitionPropertiesPreparer(ctx context.Context, organization string, project string, definitionID int32, filter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definitionId": autorest.Encode("path", definitionID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["filter"] = autorest.Encode("query", filter)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/{definitionId}/properties", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDefinitionPropertiesSender sends the GetDefinitionProperties request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDefinitionPropertiesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDefinitionPropertiesResponder handles the response to the GetDefinitionProperties request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDefinitionPropertiesResponder(resp *http.Response) (result PropertiesCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDefinitionResources sends the get definition resources request.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
func (client BaseClient) GetDefinitionResources(ctx context.Context, organization string, project string, definitionID int32) (result ListDefinitionResourceReference, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetDefinitionResources")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetDefinitionResourcesPreparer(ctx, organization, project, definitionID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitionResources", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDefinitionResourcesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitionResources", resp, "Failure sending request")
		return
	}

	result, err = client.GetDefinitionResourcesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitionResources", resp, "Failure responding to request")
	}

	return
}

// GetDefinitionResourcesPreparer prepares the GetDefinitionResources request.
func (client BaseClient) GetDefinitionResourcesPreparer(ctx context.Context, organization string, project string, definitionID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definitionId": autorest.Encode("path", definitionID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/{definitionId}/resources", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDefinitionResourcesSender sends the GetDefinitionResources request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDefinitionResourcesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDefinitionResourcesResponder handles the response to the GetDefinitionResources request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDefinitionResourcesResponder(resp *http.Response) (result ListDefinitionResourceReference, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDefinitionRevisions gets all revisions of a definition.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// definitionID - the ID of the definition.
func (client BaseClient) GetDefinitionRevisions(ctx context.Context, organization string, project string, definitionID int32) (result ListDefinitionRevision, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetDefinitionRevisions")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetDefinitionRevisionsPreparer(ctx, organization, project, definitionID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitionRevisions", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDefinitionRevisionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitionRevisions", resp, "Failure sending request")
		return
	}

	result, err = client.GetDefinitionRevisionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitionRevisions", resp, "Failure responding to request")
	}

	return
}

// GetDefinitionRevisionsPreparer prepares the GetDefinitionRevisions request.
func (client BaseClient) GetDefinitionRevisionsPreparer(ctx context.Context, organization string, project string, definitionID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definitionId": autorest.Encode("path", definitionID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/{definitionId}/revisions", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDefinitionRevisionsSender sends the GetDefinitionRevisions request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDefinitionRevisionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDefinitionRevisionsResponder handles the response to the GetDefinitionRevisions request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDefinitionRevisionsResponder(resp *http.Response) (result ListDefinitionRevision, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDefinitions gets a list of definitions.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// name - if specified, filters to definitions whose names match this pattern.
// repositoryID - a repository ID. If specified, filters to definitions that use this repository.
// repositoryType - if specified, filters to definitions that have a repository of this type.
// queryOrder - indicates the order in which definitions should be returned.
// top - the maximum number of definitions to return.
// continuationToken - a continuation token, returned by a previous call to this method, that can be used to
// return the next set of definitions.
// minMetricsTime - if specified, indicates the date from which metrics should be included.
// definitionIds - a comma-delimited list that specifies the IDs of definitions to retrieve.
// pathParameter - if specified, filters to definitions under this folder.
// builtAfter - if specified, filters to definitions that have builds after this date.
// notBuiltAfter - if specified, filters to definitions that do not have builds after this date.
// includeAllProperties - indicates whether the full definitions should be returned. By default, shallow
// representations of the definitions are returned.
// includeLatestBuilds - indicates whether to return the latest and latest completed builds for this
// definition.
// taskIDFilter - if specified, filters to definitions that use the specified task.
// processType - if specified, filters to definitions with the given process type.
// yamlFilename - if specified, filters to YAML definitions that match the given filename.
func (client BaseClient) GetDefinitions(ctx context.Context, organization string, project string, name string, repositoryID string, repositoryType string, queryOrder DefinitionQueryOrder, top *int32, continuationToken string, minMetricsTime *date.Time, definitionIds string, pathParameter string, builtAfter *date.Time, notBuiltAfter *date.Time, includeAllProperties *bool, includeLatestBuilds *bool, taskIDFilter *uuid.UUID, processType *int32, yamlFilename string) (result ListDefinitionReferenceType, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetDefinitions")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetDefinitionsPreparer(ctx, organization, project, name, repositoryID, repositoryType, queryOrder, top, continuationToken, minMetricsTime, definitionIds, pathParameter, builtAfter, notBuiltAfter, includeAllProperties, includeLatestBuilds, taskIDFilter, processType, yamlFilename)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitions", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDefinitionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitions", resp, "Failure sending request")
		return
	}

	result, err = client.GetDefinitionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitions", resp, "Failure responding to request")
	}

	return
}

// GetDefinitionsPreparer prepares the GetDefinitions request.
func (client BaseClient) GetDefinitionsPreparer(ctx context.Context, organization string, project string, name string, repositoryID string, repositoryType string, queryOrder DefinitionQueryOrder, top *int32, continuationToken string, minMetricsTime *date.Time, definitionIds string, pathParameter string, builtAfter *date.Time, notBuiltAfter *date.Time, includeAllProperties *bool, includeLatestBuilds *bool, taskIDFilter *uuid.UUID, processType *int32, yamlFilename string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(name) > 0 {
		queryParameters["name"] = autorest.Encode("query", name)
	}
	if len(repositoryID) > 0 {
		queryParameters["repositoryId"] = autorest.Encode("query", repositoryID)
	}
	if len(repositoryType) > 0 {
		queryParameters["repositoryType"] = autorest.Encode("query", repositoryType)
	}
	if len(string(queryOrder)) > 0 {
		queryParameters["queryOrder"] = autorest.Encode("query", queryOrder)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if len(continuationToken) > 0 {
		queryParameters["continuationToken"] = autorest.Encode("query", continuationToken)
	}
	if minMetricsTime != nil {
		queryParameters["minMetricsTime"] = autorest.Encode("query", *minMetricsTime)
	}
	if len(definitionIds) > 0 {
		queryParameters["definitionIds"] = autorest.Encode("query", definitionIds)
	}
	if len(pathParameter) > 0 {
		queryParameters["path"] = autorest.Encode("query", pathParameter)
	}
	if builtAfter != nil {
		queryParameters["builtAfter"] = autorest.Encode("query", *builtAfter)
	}
	if notBuiltAfter != nil {
		queryParameters["notBuiltAfter"] = autorest.Encode("query", *notBuiltAfter)
	}
	if includeAllProperties != nil {
		queryParameters["includeAllProperties"] = autorest.Encode("query", *includeAllProperties)
	}
	if includeLatestBuilds != nil {
		queryParameters["includeLatestBuilds"] = autorest.Encode("query", *includeLatestBuilds)
	}
	if taskIDFilter != nil {
		queryParameters["taskIdFilter"] = autorest.Encode("query", *taskIDFilter)
	}
	if processType != nil {
		queryParameters["processType"] = autorest.Encode("query", *processType)
	}
	if len(yamlFilename) > 0 {
		queryParameters["yamlFilename"] = autorest.Encode("query", yamlFilename)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDefinitionsSender sends the GetDefinitions request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDefinitionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDefinitionsResponder handles the response to the GetDefinitions request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDefinitionsResponder(resp *http.Response) (result ListDefinitionReferenceType, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDefinitionTags gets the tags for a definition.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// definitionID - the ID of the definition.
// revision - the definition revision number. If not specified, uses the latest revision of the definition.
func (client BaseClient) GetDefinitionTags(ctx context.Context, organization string, project string, definitionID int32, revision *int32) (result ListString, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetDefinitionTags")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetDefinitionTagsPreparer(ctx, organization, project, definitionID, revision)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitionTags", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDefinitionTagsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitionTags", resp, "Failure sending request")
		return
	}

	result, err = client.GetDefinitionTagsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetDefinitionTags", resp, "Failure responding to request")
	}

	return
}

// GetDefinitionTagsPreparer prepares the GetDefinitionTags request.
func (client BaseClient) GetDefinitionTagsPreparer(ctx context.Context, organization string, project string, definitionID int32, revision *int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definitionId": autorest.Encode("path", definitionID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if revision != nil {
		queryParameters["revision"] = autorest.Encode("query", *revision)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/{DefinitionId}/tags", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDefinitionTagsSender sends the GetDefinitionTags request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDefinitionTagsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDefinitionTagsResponder handles the response to the GetDefinitionTags request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDefinitionTagsResponder(resp *http.Response) (result ListString, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetFile gets a file from the build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// buildID - the ID of the build.
// artifactName - the name of the artifact.
// fileID - the primary key for the file.
// fileName - the name that the file will be set to.
func (client BaseClient) GetFile(ctx context.Context, organization string, project string, buildID int32, artifactName string, fileID string, fileName string) (result String, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetFile")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetFilePreparer(ctx, organization, project, buildID, artifactName, fileID, fileName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetFile", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetFileSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetFile", resp, "Failure sending request")
		return
	}

	result, err = client.GetFileResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetFile", resp, "Failure responding to request")
	}

	return
}

// GetFilePreparer prepares the GetFile request.
func (client BaseClient) GetFilePreparer(ctx context.Context, organization string, project string, buildID int32, artifactName string, fileID string, fileName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version":  APIVersion,
		"artifactName": autorest.Encode("query", artifactName),
		"fileId":       autorest.Encode("query", fileID),
		"fileName":     autorest.Encode("query", fileName),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/artifacts", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetFileSender sends the GetFile request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetFileSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetFileResponder handles the response to the GetFile request. The method always
// closes the http.Response Body.
func (client BaseClient) GetFileResponder(resp *http.Response) (result String, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetFileContents gets the contents of a file in the given source code repository.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// providerName - the name of the source provider.
// serviceEndpointID - if specified, the ID of the service endpoint to query. Can only be omitted for providers
// that do not use service endpoints, e.g. TFVC or TFGit.
// repository - if specified, the vendor-specific identifier or the name of the repository to get branches. Can
// only be omitted for providers that do not support multiple repositories.
// commitOrBranch - the identifier of the commit or branch from which a file's contents are retrieved.
// pathParameter - the path to the file to retrieve, relative to the root of the repository.
func (client BaseClient) GetFileContents(ctx context.Context, organization string, project string, providerName string, serviceEndpointID *uuid.UUID, repository string, commitOrBranch string, pathParameter string) (result String, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetFileContents")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetFileContentsPreparer(ctx, organization, project, providerName, serviceEndpointID, repository, commitOrBranch, pathParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetFileContents", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetFileContentsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetFileContents", resp, "Failure sending request")
		return
	}

	result, err = client.GetFileContentsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetFileContents", resp, "Failure responding to request")
	}

	return
}

// GetFileContentsPreparer prepares the GetFileContents request.
func (client BaseClient) GetFileContentsPreparer(ctx context.Context, organization string, project string, providerName string, serviceEndpointID *uuid.UUID, repository string, commitOrBranch string, pathParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"providerName": autorest.Encode("path", providerName),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if serviceEndpointID != nil {
		queryParameters["serviceEndpointId"] = autorest.Encode("query", *serviceEndpointID)
	}
	if len(repository) > 0 {
		queryParameters["repository"] = autorest.Encode("query", repository)
	}
	if len(commitOrBranch) > 0 {
		queryParameters["commitOrBranch"] = autorest.Encode("query", commitOrBranch)
	}
	if len(pathParameter) > 0 {
		queryParameters["path"] = autorest.Encode("query", pathParameter)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/sourceProviders/{providerName}/filecontents", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetFileContentsSender sends the GetFileContents request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetFileContentsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetFileContentsResponder handles the response to the GetFileContents request. The method always
// closes the http.Response Body.
func (client BaseClient) GetFileContentsResponder(resp *http.Response) (result String, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetFolders gets a list of build definition folders.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// pathParameter - the path to start with.
// queryOrder - the order in which folders should be returned.
func (client BaseClient) GetFolders(ctx context.Context, organization string, project string, pathParameter string, queryOrder FolderQueryOrder) (result ListFolder, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetFolders")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetFoldersPreparer(ctx, organization, project, pathParameter, queryOrder)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetFolders", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetFoldersSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetFolders", resp, "Failure sending request")
		return
	}

	result, err = client.GetFoldersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetFolders", resp, "Failure responding to request")
	}

	return
}

// GetFoldersPreparer prepares the GetFolders request.
func (client BaseClient) GetFoldersPreparer(ctx context.Context, organization string, project string, pathParameter string, queryOrder FolderQueryOrder) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"path":         autorest.Encode("path", pathParameter),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(string(queryOrder)) > 0 {
		queryParameters["queryOrder"] = autorest.Encode("query", queryOrder)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/folders/{path}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetFoldersSender sends the GetFolders request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetFoldersSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetFoldersResponder handles the response to the GetFolders request. The method always
// closes the http.Response Body.
func (client BaseClient) GetFoldersResponder(resp *http.Response) (result ListFolder, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetLatestBuild gets the latest build for a definition, optionally scoped to a specific branch.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// definition - definition name with optional leading folder path, or the definition id
// branchName - optional parameter that indicates the specific branch to use
func (client BaseClient) GetLatestBuild(ctx context.Context, organization string, project string, definition string, branchName string) (result Model, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetLatestBuild")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetLatestBuildPreparer(ctx, organization, project, definition, branchName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetLatestBuild", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetLatestBuildSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetLatestBuild", resp, "Failure sending request")
		return
	}

	result, err = client.GetLatestBuildResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetLatestBuild", resp, "Failure responding to request")
	}

	return
}

// GetLatestBuildPreparer prepares the GetLatestBuild request.
func (client BaseClient) GetLatestBuildPreparer(ctx context.Context, organization string, project string, definition string, branchName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definition":   autorest.Encode("path", definition),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(branchName) > 0 {
		queryParameters["branchName"] = autorest.Encode("query", branchName)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/latest/{definition}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetLatestBuildSender sends the GetLatestBuild request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetLatestBuildSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetLatestBuildResponder handles the response to the GetLatestBuild request. The method always
// closes the http.Response Body.
func (client BaseClient) GetLatestBuildResponder(resp *http.Response) (result Model, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPathContents gets the contents of a directory in the given source code repository.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// providerName - the name of the source provider.
// serviceEndpointID - if specified, the ID of the service endpoint to query. Can only be omitted for providers
// that do not use service endpoints, e.g. TFVC or TFGit.
// repository - if specified, the vendor-specific identifier or the name of the repository to get branches. Can
// only be omitted for providers that do not support multiple repositories.
// commitOrBranch - the identifier of the commit or branch from which a file's contents are retrieved.
// pathParameter - the path contents to list, relative to the root of the repository.
func (client BaseClient) GetPathContents(ctx context.Context, organization string, project string, providerName string, serviceEndpointID *uuid.UUID, repository string, commitOrBranch string, pathParameter string) (result ListSourceRepositoryItem, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetPathContents")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetPathContentsPreparer(ctx, organization, project, providerName, serviceEndpointID, repository, commitOrBranch, pathParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetPathContents", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPathContentsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetPathContents", resp, "Failure sending request")
		return
	}

	result, err = client.GetPathContentsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetPathContents", resp, "Failure responding to request")
	}

	return
}

// GetPathContentsPreparer prepares the GetPathContents request.
func (client BaseClient) GetPathContentsPreparer(ctx context.Context, organization string, project string, providerName string, serviceEndpointID *uuid.UUID, repository string, commitOrBranch string, pathParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"providerName": autorest.Encode("path", providerName),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if serviceEndpointID != nil {
		queryParameters["serviceEndpointId"] = autorest.Encode("query", *serviceEndpointID)
	}
	if len(repository) > 0 {
		queryParameters["repository"] = autorest.Encode("query", repository)
	}
	if len(commitOrBranch) > 0 {
		queryParameters["commitOrBranch"] = autorest.Encode("query", commitOrBranch)
	}
	if len(pathParameter) > 0 {
		queryParameters["path"] = autorest.Encode("query", pathParameter)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/sourceProviders/{providerName}/pathcontents", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPathContentsSender sends the GetPathContents request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPathContentsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetPathContentsResponder handles the response to the GetPathContents request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPathContentsResponder(resp *http.Response) (result ListSourceRepositoryItem, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetProjectMetrics gets build metrics for a project.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// metricAggregationType - the aggregation type to use (hourly, daily).
// minMetricsTime - the date from which to calculate metrics.
func (client BaseClient) GetProjectMetrics(ctx context.Context, organization string, project string, metricAggregationType string, minMetricsTime *date.Time) (result ListMetric, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetProjectMetrics")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetProjectMetricsPreparer(ctx, organization, project, metricAggregationType, minMetricsTime)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetProjectMetrics", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetProjectMetricsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetProjectMetrics", resp, "Failure sending request")
		return
	}

	result, err = client.GetProjectMetricsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetProjectMetrics", resp, "Failure responding to request")
	}

	return
}

// GetProjectMetricsPreparer prepares the GetProjectMetrics request.
func (client BaseClient) GetProjectMetricsPreparer(ctx context.Context, organization string, project string, metricAggregationType string, minMetricsTime *date.Time) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"metricAggregationType": autorest.Encode("path", metricAggregationType),
		"organization":          autorest.Encode("path", organization),
		"project":               autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if minMetricsTime != nil {
		queryParameters["minMetricsTime"] = autorest.Encode("query", *minMetricsTime)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/metrics/{metricAggregationType}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetProjectMetricsSender sends the GetProjectMetrics request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetProjectMetricsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetProjectMetricsResponder handles the response to the GetProjectMetrics request. The method always
// closes the http.Response Body.
func (client BaseClient) GetProjectMetricsResponder(resp *http.Response) (result ListMetric, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetProjectResources sends the get project resources request.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
func (client BaseClient) GetProjectResources(ctx context.Context, organization string, project string, typeParameter string, ID string) (result ListDefinitionResourceReference, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetProjectResources")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetProjectResourcesPreparer(ctx, organization, project, typeParameter, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetProjectResources", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetProjectResourcesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetProjectResources", resp, "Failure sending request")
		return
	}

	result, err = client.GetProjectResourcesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetProjectResources", resp, "Failure responding to request")
	}

	return
}

// GetProjectResourcesPreparer prepares the GetProjectResources request.
func (client BaseClient) GetProjectResourcesPreparer(ctx context.Context, organization string, project string, typeParameter string, ID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(typeParameter) > 0 {
		queryParameters["type"] = autorest.Encode("query", typeParameter)
	}
	if len(ID) > 0 {
		queryParameters["id"] = autorest.Encode("query", ID)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/authorizedresources", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetProjectResourcesSender sends the GetProjectResources request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetProjectResourcesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetProjectResourcesResponder handles the response to the GetProjectResources request. The method always
// closes the http.Response Body.
func (client BaseClient) GetProjectResourcesResponder(resp *http.Response) (result ListDefinitionResourceReference, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPullRequest gets a pull request object from source provider.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// providerName - the name of the source provider.
// pullRequestID - vendor-specific id of the pull request.
// repositoryID - vendor-specific identifier or the name of the repository that contains the pull request.
// serviceEndpointID - if specified, the ID of the service endpoint to query. Can only be omitted for providers
// that do not use service endpoints, e.g. TFVC or TFGit.
func (client BaseClient) GetPullRequest(ctx context.Context, organization string, project string, providerName string, pullRequestID string, repositoryID string, serviceEndpointID *uuid.UUID) (result PullRequest, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetPullRequest")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetPullRequestPreparer(ctx, organization, project, providerName, pullRequestID, repositoryID, serviceEndpointID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetPullRequest", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPullRequestSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetPullRequest", resp, "Failure sending request")
		return
	}

	result, err = client.GetPullRequestResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetPullRequest", resp, "Failure responding to request")
	}

	return
}

// GetPullRequestPreparer prepares the GetPullRequest request.
func (client BaseClient) GetPullRequestPreparer(ctx context.Context, organization string, project string, providerName string, pullRequestID string, repositoryID string, serviceEndpointID *uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization":  autorest.Encode("path", organization),
		"project":       autorest.Encode("path", project),
		"providerName":  autorest.Encode("path", providerName),
		"pullRequestId": autorest.Encode("path", pullRequestID),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(repositoryID) > 0 {
		queryParameters["repositoryId"] = autorest.Encode("query", repositoryID)
	}
	if serviceEndpointID != nil {
		queryParameters["serviceEndpointId"] = autorest.Encode("query", *serviceEndpointID)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/sourceProviders/{providerName}/pullrequests/{pullRequestId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPullRequestSender sends the GetPullRequest request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPullRequestSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetPullRequestResponder handles the response to the GetPullRequest request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPullRequestResponder(resp *http.Response) (result PullRequest, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetResourceUsage gets information about build resources in the system.
// Parameters:
// organization - the name of the Azure DevOps organization.
func (client BaseClient) GetResourceUsage(ctx context.Context, organization string) (result ResourceUsage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetResourceUsage")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetResourceUsagePreparer(ctx, organization)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetResourceUsage", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetResourceUsageSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetResourceUsage", resp, "Failure sending request")
		return
	}

	result, err = client.GetResourceUsageResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetResourceUsage", resp, "Failure responding to request")
	}

	return
}

// GetResourceUsagePreparer prepares the GetResourceUsage request.
func (client BaseClient) GetResourceUsagePreparer(ctx context.Context, organization string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/_apis/build/resourceusage", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetResourceUsageSender sends the GetResourceUsage request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetResourceUsageSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetResourceUsageResponder handles the response to the GetResourceUsage request. The method always
// closes the http.Response Body.
func (client BaseClient) GetResourceUsageResponder(resp *http.Response) (result ResourceUsage, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetStatusBadge <p>Gets the build status for a definition, optionally scoped to a specific branch, stage, job, and
// configuration.</p> <p>If there are more than one, then it is required to pass in a stageName value when specifying a
// jobName, and the same rule then applies for both if passing a configuration parameter.</p>
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// definition - either the definition name with optional leading folder path, or the definition id.
// branchName - only consider the most recent build for this branch.
// stageName - use this stage within the pipeline to render the status.
// jobName - use this job within a stage of the pipeline to render the status.
// configuration - use this job configuration to render the status
// label - replaces the default text on the left side of the badge.
func (client BaseClient) GetStatusBadge(ctx context.Context, organization string, project string, definition string, branchName string, stageName string, jobName string, configuration string, label string) (result String, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetStatusBadge")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetStatusBadgePreparer(ctx, organization, project, definition, branchName, stageName, jobName, configuration, label)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetStatusBadge", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetStatusBadgeSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetStatusBadge", resp, "Failure sending request")
		return
	}

	result, err = client.GetStatusBadgeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetStatusBadge", resp, "Failure responding to request")
	}

	return
}

// GetStatusBadgePreparer prepares the GetStatusBadge request.
func (client BaseClient) GetStatusBadgePreparer(ctx context.Context, organization string, project string, definition string, branchName string, stageName string, jobName string, configuration string, label string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definition":   autorest.Encode("path", definition),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(branchName) > 0 {
		queryParameters["branchName"] = autorest.Encode("query", branchName)
	}
	if len(stageName) > 0 {
		queryParameters["stageName"] = autorest.Encode("query", stageName)
	}
	if len(jobName) > 0 {
		queryParameters["jobName"] = autorest.Encode("query", jobName)
	}
	if len(configuration) > 0 {
		queryParameters["configuration"] = autorest.Encode("query", configuration)
	}
	if len(label) > 0 {
		queryParameters["label"] = autorest.Encode("query", label)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/status/{definition}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetStatusBadgeSender sends the GetStatusBadge request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetStatusBadgeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetStatusBadgeResponder handles the response to the GetStatusBadge request. The method always
// closes the http.Response Body.
func (client BaseClient) GetStatusBadgeResponder(resp *http.Response) (result String, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetTags gets a list of all build and definition tags in the project.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
func (client BaseClient) GetTags(ctx context.Context, organization string, project string) (result ListString, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetTags")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetTagsPreparer(ctx, organization, project)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetTags", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTagsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetTags", resp, "Failure sending request")
		return
	}

	result, err = client.GetTagsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetTags", resp, "Failure responding to request")
	}

	return
}

// GetTagsPreparer prepares the GetTags request.
func (client BaseClient) GetTagsPreparer(ctx context.Context, organization string, project string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/tags", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetTagsSender sends the GetTags request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetTagsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetTagsResponder handles the response to the GetTags request. The method always
// closes the http.Response Body.
func (client BaseClient) GetTagsResponder(resp *http.Response) (result ListString, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetTemplate gets a specific build definition template.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// templateID - the ID of the requested template.
func (client BaseClient) GetTemplate(ctx context.Context, organization string, project string, templateID string) (result DefinitionTemplate, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetTemplate")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetTemplatePreparer(ctx, organization, project, templateID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetTemplate", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTemplateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetTemplate", resp, "Failure sending request")
		return
	}

	result, err = client.GetTemplateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetTemplate", resp, "Failure responding to request")
	}

	return
}

// GetTemplatePreparer prepares the GetTemplate request.
func (client BaseClient) GetTemplatePreparer(ctx context.Context, organization string, project string, templateID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"templateId":   autorest.Encode("path", templateID),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/templates/{templateId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetTemplateSender sends the GetTemplate request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetTemplateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetTemplateResponder handles the response to the GetTemplate request. The method always
// closes the http.Response Body.
func (client BaseClient) GetTemplateResponder(resp *http.Response) (result DefinitionTemplate, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetTemplates gets all definition templates.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
func (client BaseClient) GetTemplates(ctx context.Context, organization string, project string) (result ListDefinitionTemplate, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetTemplates")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetTemplatesPreparer(ctx, organization, project)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetTemplates", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTemplatesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetTemplates", resp, "Failure sending request")
		return
	}

	result, err = client.GetTemplatesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetTemplates", resp, "Failure responding to request")
	}

	return
}

// GetTemplatesPreparer prepares the GetTemplates request.
func (client BaseClient) GetTemplatesPreparer(ctx context.Context, organization string, project string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/templates", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetTemplatesSender sends the GetTemplates request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetTemplatesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetTemplatesResponder handles the response to the GetTemplates request. The method always
// closes the http.Response Body.
func (client BaseClient) GetTemplatesResponder(resp *http.Response) (result ListDefinitionTemplate, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetWorkItemsBetweenBuilds gets all the work items between two builds.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// fromBuildID - the ID of the first build.
// toBuildID - the ID of the last build.
// top - the maximum number of work items to return.
func (client BaseClient) GetWorkItemsBetweenBuilds(ctx context.Context, organization string, project string, fromBuildID int32, toBuildID int32, top *int32) (result ListResourceRef, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetWorkItemsBetweenBuilds")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetWorkItemsBetweenBuildsPreparer(ctx, organization, project, fromBuildID, toBuildID, top)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetWorkItemsBetweenBuilds", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetWorkItemsBetweenBuildsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetWorkItemsBetweenBuilds", resp, "Failure sending request")
		return
	}

	result, err = client.GetWorkItemsBetweenBuildsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "GetWorkItemsBetweenBuilds", resp, "Failure responding to request")
	}

	return
}

// GetWorkItemsBetweenBuildsPreparer prepares the GetWorkItemsBetweenBuilds request.
func (client BaseClient) GetWorkItemsBetweenBuildsPreparer(ctx context.Context, organization string, project string, fromBuildID int32, toBuildID int32, top *int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"fromBuildId": autorest.Encode("query", fromBuildID),
		"toBuildId":   autorest.Encode("query", toBuildID),
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/workitems", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetWorkItemsBetweenBuildsSender sends the GetWorkItemsBetweenBuilds request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetWorkItemsBetweenBuildsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetWorkItemsBetweenBuildsResponder handles the response to the GetWorkItemsBetweenBuilds request. The method always
// closes the http.Response Body.
func (client BaseClient) GetWorkItemsBetweenBuildsResponder(resp *http.Response) (result ListResourceRef, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListBranches gets a list of branches for the given source code repository.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// providerName - the name of the source provider.
// serviceEndpointID - if specified, the ID of the service endpoint to query. Can only be omitted for providers
// that do not use service endpoints, e.g. TFVC or TFGit.
// repository - if specified, the vendor-specific identifier or the name of the repository to get branches. Can
// only be omitted for providers that do not support multiple repositories.
func (client BaseClient) ListBranches(ctx context.Context, organization string, project string, providerName string, serviceEndpointID *uuid.UUID, repository string) (result ListString, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.ListBranches")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ListBranchesPreparer(ctx, organization, project, providerName, serviceEndpointID, repository)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "ListBranches", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListBranchesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "ListBranches", resp, "Failure sending request")
		return
	}

	result, err = client.ListBranchesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "ListBranches", resp, "Failure responding to request")
	}

	return
}

// ListBranchesPreparer prepares the ListBranches request.
func (client BaseClient) ListBranchesPreparer(ctx context.Context, organization string, project string, providerName string, serviceEndpointID *uuid.UUID, repository string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"providerName": autorest.Encode("path", providerName),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if serviceEndpointID != nil {
		queryParameters["serviceEndpointId"] = autorest.Encode("query", *serviceEndpointID)
	}
	if len(repository) > 0 {
		queryParameters["repository"] = autorest.Encode("query", repository)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/sourceProviders/{providerName}/branches", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListBranchesSender sends the ListBranches request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ListBranchesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListBranchesResponder handles the response to the ListBranches request. The method always
// closes the http.Response Body.
func (client BaseClient) ListBranchesResponder(resp *http.Response) (result ListString, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListRepositories gets a list of source code repositories.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// providerName - the name of the source provider.
// serviceEndpointID - if specified, the ID of the service endpoint to query. Can only be omitted for providers
// that do not use service endpoints, e.g. TFVC or TFGit.
// repository - if specified, the vendor-specific identifier or the name of a single repository to get.
// resultSet - 'top' for the repositories most relevant for the endpoint. If not set, all repositories are
// returned. Ignored if 'repository' is set.
// pageResults - if set to true, this will limit the set of results and will return a continuation token to
// continue the query.
// continuationToken - when paging results, this is a continuation token, returned by a previous call to this
// method, that can be used to return the next set of repositories.
func (client BaseClient) ListRepositories(ctx context.Context, organization string, project string, providerName string, serviceEndpointID *uuid.UUID, repository string, resultSet ResultSet, pageResults *bool, continuationToken string) (result SourceRepositories, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.ListRepositories")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ListRepositoriesPreparer(ctx, organization, project, providerName, serviceEndpointID, repository, resultSet, pageResults, continuationToken)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "ListRepositories", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListRepositoriesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "ListRepositories", resp, "Failure sending request")
		return
	}

	result, err = client.ListRepositoriesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "ListRepositories", resp, "Failure responding to request")
	}

	return
}

// ListRepositoriesPreparer prepares the ListRepositories request.
func (client BaseClient) ListRepositoriesPreparer(ctx context.Context, organization string, project string, providerName string, serviceEndpointID *uuid.UUID, repository string, resultSet ResultSet, pageResults *bool, continuationToken string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"providerName": autorest.Encode("path", providerName),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if serviceEndpointID != nil {
		queryParameters["serviceEndpointId"] = autorest.Encode("query", *serviceEndpointID)
	}
	if len(repository) > 0 {
		queryParameters["repository"] = autorest.Encode("query", repository)
	}
	if len(string(resultSet)) > 0 {
		queryParameters["resultSet"] = autorest.Encode("query", resultSet)
	}
	if pageResults != nil {
		queryParameters["pageResults"] = autorest.Encode("query", *pageResults)
	}
	if len(continuationToken) > 0 {
		queryParameters["continuationToken"] = autorest.Encode("query", continuationToken)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/sourceProviders/{providerName}/repositories", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListRepositoriesSender sends the ListRepositories request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ListRepositoriesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListRepositoriesResponder handles the response to the ListRepositories request. The method always
// closes the http.Response Body.
func (client BaseClient) ListRepositoriesResponder(resp *http.Response) (result SourceRepositories, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListSourceProviders get a list of source providers and their capabilities.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
func (client BaseClient) ListSourceProviders(ctx context.Context, organization string, project string) (result ListSourceProviderAttributes, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.ListSourceProviders")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ListSourceProvidersPreparer(ctx, organization, project)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "ListSourceProviders", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSourceProvidersSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "ListSourceProviders", resp, "Failure sending request")
		return
	}

	result, err = client.ListSourceProvidersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "ListSourceProviders", resp, "Failure responding to request")
	}

	return
}

// ListSourceProvidersPreparer prepares the ListSourceProviders request.
func (client BaseClient) ListSourceProvidersPreparer(ctx context.Context, organization string, project string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/sourceproviders", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSourceProvidersSender sends the ListSourceProviders request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ListSourceProvidersSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListSourceProvidersResponder handles the response to the ListSourceProviders request. The method always
// closes the http.Response Body.
func (client BaseClient) ListSourceProvidersResponder(resp *http.Response) (result ListSourceProviderAttributes, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListWebhooks gets a list of webhooks installed in the given source code repository.
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// providerName - the name of the source provider.
// serviceEndpointID - if specified, the ID of the service endpoint to query. Can only be omitted for providers
// that do not use service endpoints, e.g. TFVC or TFGit.
// repository - if specified, the vendor-specific identifier or the name of the repository to get webhooks. Can
// only be omitted for providers that do not support multiple repositories.
func (client BaseClient) ListWebhooks(ctx context.Context, organization string, project string, providerName string, serviceEndpointID *uuid.UUID, repository string) (result ListRepositoryWebhook, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.ListWebhooks")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ListWebhooksPreparer(ctx, organization, project, providerName, serviceEndpointID, repository)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "ListWebhooks", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListWebhooksSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "ListWebhooks", resp, "Failure sending request")
		return
	}

	result, err = client.ListWebhooksResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "ListWebhooks", resp, "Failure responding to request")
	}

	return
}

// ListWebhooksPreparer prepares the ListWebhooks request.
func (client BaseClient) ListWebhooksPreparer(ctx context.Context, organization string, project string, providerName string, serviceEndpointID *uuid.UUID, repository string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"providerName": autorest.Encode("path", providerName),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if serviceEndpointID != nil {
		queryParameters["serviceEndpointId"] = autorest.Encode("query", *serviceEndpointID)
	}
	if len(repository) > 0 {
		queryParameters["repository"] = autorest.Encode("query", repository)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/sourceProviders/{providerName}/webhooks", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListWebhooksSender sends the ListWebhooks request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ListWebhooksSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListWebhooksResponder handles the response to the ListWebhooks request. The method always
// closes the http.Response Body.
func (client BaseClient) ListWebhooksResponder(resp *http.Response) (result ListRepositoryWebhook, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// QueueBuild queues a build
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
func (client BaseClient) QueueBuild(ctx context.Context, organization string, body Model, project string, ignoreWarnings *bool, checkInTicket string, sourceBuildID *int32) (result Model, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.QueueBuild")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body.TriggeredByBuild", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("build.BaseClient", "QueueBuild", err.Error())
	}

	req, err := client.QueueBuildPreparer(ctx, organization, body, project, ignoreWarnings, checkInTicket, sourceBuildID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "QueueBuild", nil, "Failure preparing request")
		return
	}

	resp, err := client.QueueBuildSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "QueueBuild", resp, "Failure sending request")
		return
	}

	result, err = client.QueueBuildResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "QueueBuild", resp, "Failure responding to request")
	}

	return
}

// QueueBuildPreparer prepares the QueueBuild request.
func (client BaseClient) QueueBuildPreparer(ctx context.Context, organization string, body Model, project string, ignoreWarnings *bool, checkInTicket string, sourceBuildID *int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if ignoreWarnings != nil {
		queryParameters["ignoreWarnings"] = autorest.Encode("query", *ignoreWarnings)
	}
	if len(checkInTicket) > 0 {
		queryParameters["checkInTicket"] = autorest.Encode("query", checkInTicket)
	}
	if sourceBuildID != nil {
		queryParameters["sourceBuildId"] = autorest.Encode("query", *sourceBuildID)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// QueueBuildSender sends the QueueBuild request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) QueueBuildSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// QueueBuildResponder handles the response to the QueueBuild request. The method always
// closes the http.Response Body.
func (client BaseClient) QueueBuildResponder(resp *http.Response) (result Model, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// RestoreDefinition restores a deleted definition
// Parameters:
// organization - the name of the Azure DevOps organization.
// project - project ID or project name
// definitionID - the identifier of the definition to restore.
// deleted - when false, restores a deleted definition.
func (client BaseClient) RestoreDefinition(ctx context.Context, organization string, project string, definitionID int32, deleted bool) (result Definition, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.RestoreDefinition")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.RestoreDefinitionPreparer(ctx, organization, project, definitionID, deleted)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "RestoreDefinition", nil, "Failure preparing request")
		return
	}

	resp, err := client.RestoreDefinitionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "RestoreDefinition", resp, "Failure sending request")
		return
	}

	result, err = client.RestoreDefinitionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "RestoreDefinition", resp, "Failure responding to request")
	}

	return
}

// RestoreDefinitionPreparer prepares the RestoreDefinition request.
func (client BaseClient) RestoreDefinitionPreparer(ctx context.Context, organization string, project string, definitionID int32, deleted bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definitionId": autorest.Encode("path", definitionID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"deleted":     autorest.Encode("query", deleted),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/{definitionId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestoreDefinitionSender sends the RestoreDefinition request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RestoreDefinitionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RestoreDefinitionResponder handles the response to the RestoreDefinition request. The method always
// closes the http.Response Body.
func (client BaseClient) RestoreDefinitionResponder(resp *http.Response) (result Definition, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// RestoreWebhooks recreates the webhooks for the specified triggers in the given source code repository.
// Parameters:
// organization - the name of the Azure DevOps organization.
// body - the types of triggers to restore webhooks for.
// project - project ID or project name
// providerName - the name of the source provider.
// serviceEndpointID - if specified, the ID of the service endpoint to query. Can only be omitted for providers
// that do not use service endpoints, e.g. TFVC or TFGit.
// repository - if specified, the vendor-specific identifier or the name of the repository to get webhooks. Can
// only be omitted for providers that do not support multiple repositories.
func (client BaseClient) RestoreWebhooks(ctx context.Context, organization string, body []string, project string, providerName string, serviceEndpointID *uuid.UUID, repository string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.RestoreWebhooks")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("build.BaseClient", "RestoreWebhooks", err.Error())
	}

	req, err := client.RestoreWebhooksPreparer(ctx, organization, body, project, providerName, serviceEndpointID, repository)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "RestoreWebhooks", nil, "Failure preparing request")
		return
	}

	resp, err := client.RestoreWebhooksSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "build.BaseClient", "RestoreWebhooks", resp, "Failure sending request")
		return
	}

	result, err = client.RestoreWebhooksResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "RestoreWebhooks", resp, "Failure responding to request")
	}

	return
}

// RestoreWebhooksPreparer prepares the RestoreWebhooks request.
func (client BaseClient) RestoreWebhooksPreparer(ctx context.Context, organization string, body []string, project string, providerName string, serviceEndpointID *uuid.UUID, repository string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"providerName": autorest.Encode("path", providerName),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if serviceEndpointID != nil {
		queryParameters["serviceEndpointId"] = autorest.Encode("query", *serviceEndpointID)
	}
	if len(repository) > 0 {
		queryParameters["repository"] = autorest.Encode("query", repository)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/sourceProviders/{providerName}/webhooks", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestoreWebhooksSender sends the RestoreWebhooks request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RestoreWebhooksSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// RestoreWebhooksResponder handles the response to the RestoreWebhooks request. The method always
// closes the http.Response Body.
func (client BaseClient) RestoreWebhooksResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// SaveTemplate updates an existing build definition template.
// Parameters:
// organization - the name of the Azure DevOps organization.
// body - the new version of the template.
// project - project ID or project name
// templateID - the ID of the template.
func (client BaseClient) SaveTemplate(ctx context.Context, organization string, body DefinitionTemplate, project string, templateID string) (result DefinitionTemplate, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.SaveTemplate")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.SaveTemplatePreparer(ctx, organization, body, project, templateID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "SaveTemplate", nil, "Failure preparing request")
		return
	}

	resp, err := client.SaveTemplateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "SaveTemplate", resp, "Failure sending request")
		return
	}

	result, err = client.SaveTemplateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "SaveTemplate", resp, "Failure responding to request")
	}

	return
}

// SaveTemplatePreparer prepares the SaveTemplate request.
func (client BaseClient) SaveTemplatePreparer(ctx context.Context, organization string, body DefinitionTemplate, project string, templateID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
		"templateId":   autorest.Encode("path", templateID),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/templates/{templateId}", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// SaveTemplateSender sends the SaveTemplate request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) SaveTemplateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// SaveTemplateResponder handles the response to the SaveTemplate request. The method always
// closes the http.Response Body.
func (client BaseClient) SaveTemplateResponder(resp *http.Response) (result DefinitionTemplate, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateBuild updates a build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// body - the build.
// project - project ID or project name
// buildID - the ID of the build.
func (client BaseClient) UpdateBuild(ctx context.Context, organization string, body Model, project string, buildID int32, retry *bool) (result Model, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateBuild")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateBuildPreparer(ctx, organization, body, project, buildID, retry)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateBuild", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateBuildSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateBuild", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateBuildResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateBuild", resp, "Failure responding to request")
	}

	return
}

// UpdateBuildPreparer prepares the UpdateBuild request.
func (client BaseClient) UpdateBuildPreparer(ctx context.Context, organization string, body Model, project string, buildID int32, retry *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if retry != nil {
		queryParameters["retry"] = autorest.Encode("query", *retry)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateBuildSender sends the UpdateBuild request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateBuildSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateBuildResponder handles the response to the UpdateBuild request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateBuildResponder(resp *http.Response) (result Model, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateBuildProperties updates properties for a build.
// Parameters:
// organization - the name of the Azure DevOps organization.
// body - a json-patch document describing the properties to update.
// project - project ID or project name
// buildID - the ID of the build.
func (client BaseClient) UpdateBuildProperties(ctx context.Context, organization string, body interface{}, project string, buildID int32) (result PropertiesCollection, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateBuildProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateBuildPropertiesPreparer(ctx, organization, body, project, buildID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateBuildProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateBuildPropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateBuildProperties", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateBuildPropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateBuildProperties", resp, "Failure responding to request")
	}

	return
}

// UpdateBuildPropertiesPreparer prepares the UpdateBuildProperties request.
func (client BaseClient) UpdateBuildPropertiesPreparer(ctx context.Context, organization string, body interface{}, project string, buildID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"buildId":      autorest.Encode("path", buildID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json-patch+json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds/{buildId}/properties", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateBuildPropertiesSender sends the UpdateBuildProperties request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateBuildPropertiesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateBuildPropertiesResponder handles the response to the UpdateBuildProperties request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateBuildPropertiesResponder(resp *http.Response) (result PropertiesCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateBuilds updates multiple builds.
// Parameters:
// organization - the name of the Azure DevOps organization.
// body - the builds to update.
// project - project ID or project name
func (client BaseClient) UpdateBuilds(ctx context.Context, organization string, body []Model, project string) (result ListModel, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateBuilds")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("build.BaseClient", "UpdateBuilds", err.Error())
	}

	req, err := client.UpdateBuildsPreparer(ctx, organization, body, project)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateBuilds", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateBuildsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateBuilds", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateBuildsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateBuilds", resp, "Failure responding to request")
	}

	return
}

// UpdateBuildsPreparer prepares the UpdateBuilds request.
func (client BaseClient) UpdateBuildsPreparer(ctx context.Context, organization string, body []Model, project string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/builds", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateBuildsSender sends the UpdateBuilds request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateBuildsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateBuildsResponder handles the response to the UpdateBuilds request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateBuildsResponder(resp *http.Response) (result ListModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateBuildSettings updates the build settings.
// Parameters:
// organization - the name of the Azure DevOps organization.
// body - the new settings.
// project - project ID or project name
func (client BaseClient) UpdateBuildSettings(ctx context.Context, organization string, body Settings, project string) (result Settings, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateBuildSettings")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateBuildSettingsPreparer(ctx, organization, body, project)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateBuildSettings", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateBuildSettingsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateBuildSettings", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateBuildSettingsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateBuildSettings", resp, "Failure responding to request")
	}

	return
}

// UpdateBuildSettingsPreparer prepares the UpdateBuildSettings request.
func (client BaseClient) UpdateBuildSettingsPreparer(ctx context.Context, organization string, body Settings, project string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/settings", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateBuildSettingsSender sends the UpdateBuildSettings request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateBuildSettingsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateBuildSettingsResponder handles the response to the UpdateBuildSettings request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateBuildSettingsResponder(resp *http.Response) (result Settings, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateDefinition updates an existing definition.
// Parameters:
// organization - the name of the Azure DevOps organization.
// body - the new version of the defintion.
// project - project ID or project name
// definitionID - the ID of the definition.
func (client BaseClient) UpdateDefinition(ctx context.Context, organization string, body Definition, project string, definitionID int32, secretsSourceDefinitionID *int32, secretsSourceDefinitionRevision *int32) (result Definition, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateDefinition")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateDefinitionPreparer(ctx, organization, body, project, definitionID, secretsSourceDefinitionID, secretsSourceDefinitionRevision)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateDefinition", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateDefinitionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateDefinition", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateDefinitionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateDefinition", resp, "Failure responding to request")
	}

	return
}

// UpdateDefinitionPreparer prepares the UpdateDefinition request.
func (client BaseClient) UpdateDefinitionPreparer(ctx context.Context, organization string, body Definition, project string, definitionID int32, secretsSourceDefinitionID *int32, secretsSourceDefinitionRevision *int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definitionId": autorest.Encode("path", definitionID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if secretsSourceDefinitionID != nil {
		queryParameters["secretsSourceDefinitionId"] = autorest.Encode("query", *secretsSourceDefinitionID)
	}
	if secretsSourceDefinitionRevision != nil {
		queryParameters["secretsSourceDefinitionRevision"] = autorest.Encode("query", *secretsSourceDefinitionRevision)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/{definitionId}", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateDefinitionSender sends the UpdateDefinition request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateDefinitionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateDefinitionResponder handles the response to the UpdateDefinition request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateDefinitionResponder(resp *http.Response) (result Definition, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateDefinitionProperties updates properties for a definition.
// Parameters:
// organization - the name of the Azure DevOps organization.
// body - a json-patch document describing the properties to update.
// project - project ID or project name
// definitionID - the ID of the definition.
func (client BaseClient) UpdateDefinitionProperties(ctx context.Context, organization string, body interface{}, project string, definitionID int32) (result PropertiesCollection, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateDefinitionProperties")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateDefinitionPropertiesPreparer(ctx, organization, body, project, definitionID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateDefinitionProperties", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateDefinitionPropertiesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateDefinitionProperties", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateDefinitionPropertiesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateDefinitionProperties", resp, "Failure responding to request")
	}

	return
}

// UpdateDefinitionPropertiesPreparer prepares the UpdateDefinitionProperties request.
func (client BaseClient) UpdateDefinitionPropertiesPreparer(ctx context.Context, organization string, body interface{}, project string, definitionID int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"definitionId": autorest.Encode("path", definitionID),
		"organization": autorest.Encode("path", organization),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json-patch+json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/definitions/{definitionId}/properties", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateDefinitionPropertiesSender sends the UpdateDefinitionProperties request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateDefinitionPropertiesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateDefinitionPropertiesResponder handles the response to the UpdateDefinitionProperties request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateDefinitionPropertiesResponder(resp *http.Response) (result PropertiesCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateFolder updates an existing folder at given  existing path
// Parameters:
// organization - the name of the Azure DevOps organization.
// body - the new version of the folder.
// project - project ID or project name
// pathParameter - the full path to the folder.
func (client BaseClient) UpdateFolder(ctx context.Context, organization string, body Folder, project string, pathParameter string) (result Folder, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateFolder")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateFolderPreparer(ctx, organization, body, project, pathParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateFolder", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateFolderSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateFolder", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateFolderResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "build.BaseClient", "UpdateFolder", resp, "Failure responding to request")
	}

	return
}

// UpdateFolderPreparer prepares the UpdateFolder request.
func (client BaseClient) UpdateFolderPreparer(ctx context.Context, organization string, body Folder, project string, pathParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"organization": autorest.Encode("path", organization),
		"path":         autorest.Encode("path", pathParameter),
		"project":      autorest.Encode("path", project),
	}

	const APIVersion = "5.1-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/{organization}/{project}/_apis/build/folders/{path}", pathParameters),
		autorest.WithJSON(body),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateFolderSender sends the UpdateFolder request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateFolderSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateFolderResponder handles the response to the UpdateFolder request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateFolderResponder(resp *http.Response) (result Folder, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
